<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PVF Web Browser</title>
    <link href="libs/prism-tomorrow.min.css" rel="stylesheet" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            scroll-padding-bottom: env(safe-area-inset-bottom, 20px);
        }

        header {
            background: #252526;
            padding: 8px 10px;
            display: flex;
            gap: 8px;
            align-items: center;
            border-bottom: 1px solid #3c3c3c;
            flex-wrap: wrap;
        }

        header h1 {
            font-size: 16px;
            margin-right: auto;
            white-space: nowrap;
        }

        button, input, select {
            padding: 6px 10px;
            background: #3c3c3c;
            border: 1px solid #555;
            color: #d4d4d4;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            background: #4a4a4a;
        }

        button:active {
            transform: scale(0.98);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        input {
            cursor: text;
        }

        /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
        @media (max-width: 768px) {
            header {
                padding: 6px 8px;
                gap: 6px;
            }

            header h1 {
                font-size: 14px;
            }

            button, input, select {
                padding: 5px 8px;
                font-size: 13px;
            }

            /* éšè—éƒ¨åˆ†æŒ‰é’®ï¼Œç”¨èœå•æ›¿ä»£ */
            .desktop-only {
                display: none;
            }

            /* ä¸ºæµè§ˆå™¨åº•éƒ¨èœå•æ é¢„ç•™ç©ºé—´ */
            .file-viewer {
                padding-bottom: max(env(safe-area-inset-bottom), 40px);
            }
        }

        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        .sidebar {
            width: 280px;
            background: #252526;
            border-right: 1px solid #3c3c3c;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
            z-index: 100;
        }

        .sidebar.collapsed {
            transform: translateX(-100%);
            position: absolute;
        }

        .sidebar-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 90;
        }

        .sidebar-overlay.show {
            display: block;
        }

        .sidebar-header {
            padding: 10px;
            background: #2d2d2d;
            border-bottom: 1px solid #3c3c3c;
        }

        .sidebar-header input {
            width: 100%;
        }

        .sidebar-tabs {
            display: flex;
            border-bottom: 1px solid #3c3c3c;
            background: #2d2d2d;
        }

        .sidebar-tab {
            flex: 1;
            padding: 8px 12px;
            text-align: center;
            cursor: pointer;
            font-size: 13px;
            color: #858585;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .sidebar-tab:hover {
            background: #3c3c3c;
            color: #d4d4d4;
        }

        .sidebar-tab.active {
            color: #d4d4d4;
            border-bottom-color: #007acc;
            background: #252526;
        }

        .file-tree {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            scroll-padding-bottom: env(safe-area-inset-bottom, 20px);
        }

        .search-results {
            flex: 1;
            overflow-y: auto;
            padding: 8px;
            scroll-padding-bottom: env(safe-area-inset-bottom, 20px);
        }

        .search-result-item {
            padding: 8px 10px;
            cursor: pointer;
            border-bottom: 1px solid #2d2d2d;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .search-result-item:hover {
            background: #2a2d2e;
        }

        .search-result-name {
            font-size: 13px;
            color: #d4d4d4;
        }

        .search-result-path {
            font-size: 11px;
            color: #858585;
            font-family: 'Consolas', monospace;
        }

        .search-result-match {
            font-size: 11px;
            color: #4ec9b0;
            font-family: 'Consolas', monospace;
        }

        .file-item {
            padding: 8px 10px;
            cursor: pointer;
            border-radius: 3px;
            display: flex;
            align-items: center;
            gap: 8px;
            user-select: none;
        }

        .file-item:hover {
            background: #2a2d2e;
        }

        .file-item.selected {
            background: #094771;
            border-left: 3px solid #007acc;
        }

        .file-item .toggle-icon {
            width: 16px;
            text-align: center;
            font-size: 10px;
            color: #858585;
            transition: transform 0.2s;
        }

        .file-item.folder-item .toggle-icon:hover {
            color: #d4d4d4;
        }

        .file-item.back-item {
            color: #4ec9b0;
            font-weight: 500;
        }

        .file-item.back-item:hover {
            background: #2a2d2e;
        }

        .folder-children {
            border-left: 1px solid #3c3c3c;
            margin-left: 8px;
        }

        .file-item.folder {
            font-weight: 500;
        }

        .file-item .icon {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            flex-shrink: 0;
        }

        .file-item .name {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .file-item .size {
            font-size: 11px;
            color: #858585;
            flex-shrink: 0;
        }

        .file-item .checkbox {
            width: 18px;
            height: 18px;
            margin-right: 8px;
            cursor: pointer;
            flex-shrink: 0;
        }

        .file-item .checkbox input {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        .batch-actions {
            display: none;
            padding: 8px 12px;
            background: #2d2d2d;
            border-bottom: 1px solid #3c3c3c;
            gap: 8px;
        }

        .batch-actions.show {
            display: flex;
        }

        .batch-actions .selected-count {
            flex: 1;
            display: flex;
            align-items: center;
            font-size: 13px;
            color: #d4d4d4;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: visible;
            min-width: 0;
            position: relative;
        }

        .content-header {
            padding: 8px 12px;
            background: #2d2d2d;
            border-bottom: 1px solid #3c3c3c;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }

        .content-header .path {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 13px;
            color: #858585;
        }

        .content-header .actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }

        .toggle-sidebar-btn {
            display: none;
            background: #3c3c3c;
            border: 1px solid #555;
            color: #d4d4d4;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
        }

        @media (max-width: 768px) {
            .sidebar {
                position: absolute;
                left: 0;
                top: 0;
                bottom: 0;
                width: 85%;
                max-width: 300px;
                box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3);
            }

            .toggle-sidebar-btn {
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .content-header {
                padding: 6px 10px;
            }

            .content-header .path {
                font-size: 12px;
            }

            .file-item {
                padding: 10px 8px;
                font-size: 15px;
            }

            .file-item .size {
                font-size: 12px;
            }
        }

        .menu-bar {
            background: #2d2d2d;
            border-bottom: 1px solid #3c3c3c;
            padding: 4px 8px;
            display: flex;
            gap: 2px;
            font-size: 13px;
            transition: height 0.3s ease;
            overflow: hidden;
            position: relative;
            z-index: 100;
        }

        .menu-bar.collapsed {
            height: 0;
            padding: 0;
            border-bottom: none;
        }

        .menu-item {
            padding: 4px 12px;
            cursor: pointer;
            border-radius: 2px;
            position: relative;
            z-index: 101;
        }

        .menu-item:hover {
            background: #3c3c3c;
        }

        .menu-dropdown {
            display: none;
            position: fixed;
            min-width: 250px;
            max-height: 400px;
            overflow-y: auto;
            z-index: 150;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
            background: #252526;
            border: 1px solid #3c3c3c;
        }

        .menu-dropdown.show {
    display: block;
        }

        /* ç§»é™¤è‡ªåŠ¨hoveræ˜¾ç¤ºï¼Œä½¿ç”¨JavaScriptæ§åˆ¶ */

        .menu-dropdown-item {
            padding: 8px 16px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .menu-dropdown-item:hover {
            background: #3c3c3c;
        }

        .menu-dropdown-item .shortcut {
            color: #858585;
            font-size: 11px;
        }

        .menu-dropdown-item .delete-btn {
            padding: 2px 6px;
            font-size: 10px;
            background: #3c3c3c;
            border: 1px solid #555;
            color: #d4d4d4;
            border-radius: 2px;
            margin-left: 8px;
        }

        .menu-dropdown-item .delete-btn:hover {
            background: #4a4a4a;
        }

        .menu-dropdown-divider {
            border-top: 1px solid #3c3c3c;
            margin: 4px 0;
        }

        .menu-dropdown-empty {
            padding: 12px 16px;
            color: #858585;
            font-size: 12px;
            text-align: center;
        }

        .toolbar {
            background: #2d2d2d;
            border-bottom: 1px solid #3c3c3c;
            padding: 6px 12px;
            display: flex;
            gap: 6px;
            align-items: center;
            flex-wrap: wrap;
            transition: height 0.3s ease;
            overflow: hidden;
        }

        .toolbar.collapsed {
            height: 0;
            padding: 0;
            border-bottom: none;
        }

        .toolbar-group {
            display: flex;
            gap: 6px;
            align-items: center;
            padding-right: 12px;
            border-right: 1px solid #3c3c3c;
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        .toolbar-separator {
            width: 1px;
            height: 20px;
            background: #3c3c3c;
            margin: 0 4px;
        }

        .toolbar label {
            font-size: 12px;
            color: #858585;
            margin-right: 4px;
        }

        .toggle-controls {
            background: #2d2d2d;
            border-bottom: 1px solid #3c3c3c;
            padding: 4px 8px;
            display: flex;
            gap: 4px;
            justify-content: flex-end;
        }

        .toggle-controls .toggle-toolbar-btn {
            margin-left: 0;
            font-size: 12px;
            padding: 3px 8px;
        }

        .toggle-toolbar-btn {
            background: #3c3c3c;
            border: 1px solid #555;
            color: #d4d4d4;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
            margin-left: auto;
        }

        .toggle-toolbar-btn:hover {
            background: #4a4a4a;
        }

        @media (max-width: 768px) {
            .menu-bar {
                font-size: 12px;
            }

            .menu-item {
                padding: 4px 8px;
            }

            .toolbar {
                padding: 4px 8px;
            }

            .toolbar-group {
                padding-right: 6px;
            }

            .toolbar label {
                display: none;
            }
        }

        /* æ ‡ç­¾é¡µæ  */
        .tabs-bar {
            background: #252526;
            border-bottom: 1px solid #3c3c3c;
            min-height: 35px;
            display: flex;
            align-items: center;
            overflow-x: auto;
            overflow-y: hidden;
        }

        .tabs-container {
            display: flex;
            gap: 2px;
            padding: 0 8px;
        }

        .tab {
            display: flex;
            align-items: center;
            padding: 6px 12px;
            background: #2d2d2d;
            border: 1px solid #3c3c3c;
            border-bottom: none;
            border-radius: 4px 4px 0 0;
            cursor: pointer;
            min-width: 100px;
            max-width: 200px;
            user-select: none;
            transition: background 0.2s;
        }

        .tab:hover {
            background: #3c3c3c;
        }

        .tab.active {
            background: #1e1e1e;
            border-bottom: 1px solid #1e1e1e;
        }

        .tab-title {
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            font-size: 13px;
        }

        .tab-close {
            margin-left: 8px;
            width: 16px;
            height: 16px;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            color: #858585;
        }

        .tab-close:hover {
            background: #505050;
            color: #d4d4d4;
        }

        /* å¯ç‚¹å‡»çš„è·¯å¾„é“¾æ¥ */
        .path-link {
            color: #4ec9b0;
            text-decoration: underline;
            cursor: pointer;
            padding: 0 2px;
            border-radius: 2px;
        }

        .path-link:hover {
            background: rgba(78, 201, 176, 0.1);
        }

        .file-viewer {
            flex: 1;
            overflow: auto;
            padding: 0;
            position: relative;
        }

        /* ç§»åŠ¨ç«¯åº•éƒ¨å®‰å…¨åŒºåŸŸé€‚é… */
        @media (max-width: 768px) {
            .file-viewer {
                padding-bottom: env(safe-area-inset-bottom, 20px);
            }
        }

        /* è™šæ‹Ÿæ»šåŠ¨å®¹å™¨ */
        .virtual-scroll-container {
            position: relative;
            height: 100%;
            overflow: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            line-height: 1.6;
            scroll-padding-bottom: env(safe-area-inset-bottom, 20px);
            overflow-x: auto;
            overflow-y: scroll;
            -webkit-overflow-scrolling: touch;
        }

        .virtual-scroll-content {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            min-width: 100%;
        }

        .virtual-scroll-viewport {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            min-width: 100%;
        }

        /* è¡Œå· */
        .line-numbers {
            background: #1e1e1e;
            border-right: 0.5px solid #3c3c3c;
            text-align: right;
            padding-right: 2px;
            color: #858585;
            user-select: none;
            flex-shrink: 0;
        }

        .line-number {
            height: 19.2px; /* line-height 1.6 * 12px */
            line-height: 19.2px;
            font-size: 12px;
            min-width: 20px;
        }

        /* ä»£ç å†…å®¹ */
        .code-content {
            padding-left: 2px;
            white-space: pre;
            flex: 1;
            overflow: auto;
        }

        /* è¡Œå·å’Œä»£ç çš„åŒ…è£…å®¹å™¨ */
        .code-with-lines {
            display: flex;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            line-height: 1.6;
            overflow-x: auto;
        }

        .code-line {
            min-height: 19.2px;
            line-height: 19.2px;
            font-size: 12px;
            white-space: nowrap;
        }

        .file-viewer pre {
            background: #1e1e1e;
            padding: 12px;
            border-radius: 4px;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 12px;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
            margin: 0;
            /* æ˜¾ç¤ºç©ºç™½å­—ç¬¦ */
            white-space: pre-wrap;
        }

        /* æ˜¾ç¤ºç©ºç™½å­—ç¬¦çš„æ ·å¼ */
        .show-whitespace {
            white-space: pre-wrap !important;
        }

        .show-whitespace code {
            white-space: pre-wrap !important;
        }

        /* ç©ºç™½å­—ç¬¦æ˜¾ç¤ºæ ·å¼ */
        .whitespace-tab {
            color: #808080;
            opacity: 0.5;
            display: inline-block;
            margin-right: 2px;
        }

        .whitespace-space {
            color: #808080;
            opacity: 0.5;
            font-size: 0.8em;
        }

        /* æ¢è¡Œç¬¦æ˜¾ç¤º */
        .show-whitespace .token.whitespace-newline {
            color: #808080;
            opacity: 0.3;
        }

        /* PVF è„šæœ¬è¯­æ³•é«˜äº®ï¼ˆåŸºäº pvfut æºç ï¼‰ */
        
        /* æ ‡ç­¾/èŠ‚ [name], [code] ç­‰ */
        .token.section {
            color: #569cd6;
            font-weight: bold;
        }
        
        .token.section .bracket {
            color: #ffd700;
        }
        
        .token.section .content .keyword {
            color: #c586c0;
            font-weight: bold;
        }
        
        /* å­—ç¬¦ä¸² `...` */
        .token.string {
            color: #ce9178;
        }
        
        /* å­—ç¬¦ä¸²é“¾æ¥ <id::name`æ–‡å­—`> */
        .token.string-link {
            color: #4ec9b0;
            font-style: italic;
        }
        
        .token.string-link .punctuation {
            color: #569cd6;
        }
        
        .token.string-link .id {
            color: #b5cea8;
        }
        
        .token.string-link .separator {
            color: #d4d4d4;
        }
        
        /* æ³¨é‡Š */
        .token.comment {
            color: #6a9955;
            font-style: italic;
        }
        
        /* æ•°å­— */
        .token.number {
            color: #b5cea8;
        }
        
        /* æ ‡è¯†ç¬¦ */
        .token.identifier {
            color: #9cdcfe;
        }
        
        /* è¿ç®—ç¬¦ */
        .token.operator {
            color: #d4d4d4;
        }
        
        /* æ ‡ç‚¹ç¬¦å· */
        .token.punctuation {
            color: #d4d4d4;
        }

        .file-viewer .empty {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: #858585;
            font-size: 14px;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 20px;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: #252526;
            padding: 20px;
            border-radius: 8px;
            min-width: 300px;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            margin-bottom: 15px;
            font-size: 18px;
            font-weight: 500;
        }

        .modal-body {
            margin-bottom: 15px;
        }

        .modal-body input {
            width: 100%;
            margin-bottom: 10px;
        }

        .modal-body textarea {
            width: 100%;
            min-height: 300px;
            max-height: 70vh;
            background: #1e1e1e;
            border: 1px solid #3c3c3c;
            color: #d4d4d4;
            padding: 10px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            line-height: 1.6;
            resize: vertical;
        }

        .modal-body textarea:focus {
            outline: none;
            border-color: #007acc;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        @media (max-width: 768px) {
            .modal-content {
                padding: 15px;
                min-width: auto;
                width: 100%;
            }

            .modal-header {
                font-size: 16px;
                margin-bottom: 12px;
            }

            .modal-footer {
                flex-direction: column;
            }

            .modal-footer button {
                width: 100%;
            }
        }

        .status-bar {
            padding: 4px 12px;
            background: #007acc;
            color: white;
            font-size: 12px;
            flex-shrink: 0;
        }

        .loading {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 20px 30px;
            border-radius: 8px;
            z-index: 1001;
            font-size: 14px;
        }

        .loading.show {
            display: block;
        }

        /* è¿”å›æŒ‰é’® */
        .back-btn {
            display: none;
            background: #3c3c3c;
            border: 1px solid #555;
            color: #d4d4d4;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        @media (max-width: 768px) {
            .back-btn {
                display: flex;
                align-items: center;
                gap: 4px;
            }
        }

        /* é«˜çº§æœç´¢å¯¹è¯æ¡†æ ·å¼ */
        .search-modal-content {
            max-width: 550px;
            background: linear-gradient(135deg, #2a2a2e 0%, #252526 100%);
            border: 1px solid #3c3c3c;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
        }

        .search-field-group {
            margin-bottom: 20px;
        }

        .search-label {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 14px;
            font-weight: 500;
            color: #d4d4d4;
        }

        .search-icon {
            font-size: 16px;
        }

        .search-select,
        .search-input {
            width: 100%;
            padding: 10px 12px;
            background: #1e1e1e;
            border: 1px solid #3c3c3c;
            border-radius: 6px;
            color: #d4d4d4;
            font-size: 14px;
            transition: all 0.2s ease;
        }

        .search-select:focus,
        .search-input:focus {
            outline: none;
            border-color: #007acc;
            box-shadow: 0 0 0 3px rgba(0, 122, 204, 0.1);
        }

        .search-input::placeholder {
            color: #858585;
        }

        .search-options-group {
            margin-top: 24px;
            padding: 16px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            border: 1px solid #3c3c3c;
        }

        .search-section-label {
            display: block;
            margin-bottom: 12px;
            font-size: 13px;
            font-weight: 600;
            color: #858585;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .search-checkbox-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
        }

        .search-checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            background: #2d2d32;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            user-select: none;
        }

        .search-checkbox-label:hover {
            background: #38383d;
            transform: translateY(-1px);
        }

        .search-checkbox-label input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #007acc;
        }

        .checkbox-text {
            font-size: 13px;
            color: #d4d4d4;
        }

        .search-footer {
            padding-top: 20px;
            border-top: 1px solid #3c3c3c;
        }

        .search-btn {
            padding: 10px 24px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
        }

        .cancel-btn {
            background: #3c3c3c;
            color: #d4d4d4;
        }

        .cancel-btn:hover {
            background: #4a4a4a;
        }

        .search-confirm-btn {
            background: linear-gradient(135deg, #007acc 0%, #005a9e 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(0, 122, 204, 0.3);
        }

        .search-confirm-btn:hover {
            background: linear-gradient(135deg, #0086e6 0%, #0066b3 100%);
            box-shadow: 0 4px 12px rgba(0, 122, 204, 0.4);
            transform: translateY(-1px);
        }

        .search-confirm-btn:active {
            transform: translateY(0);
        }

        /* åç§°é¢„è§ˆæ ·å¼ */
        .name-preview {
            color: #6a6a6a;
            font-size: 11px;
            font-style: italic;
            opacity: 0.7;
            user-select: none;
            margin-left: 8px;
        }

        /* ç§»åŠ¨ç«¯ä¼˜åŒ– */
        @media (max-width: 768px) {
            .search-modal-content {
                max-width: 95%;
                border-radius: 12px;
            }

            .search-checkbox-grid {
                grid-template-columns: 1fr;
            }

            .search-footer {
                flex-direction: column;
                gap: 10px;
            }

            .search-btn {
                width: 100%;
            }
        }

        /* é¢åŒ…å±‘å¯¼èˆª */
        .breadcrumb {
            display: flex;
            align-items: center;
            gap: 4px;
            overflow-x: auto;
            white-space: nowrap;
            font-size: 12px;
            color: #858585;
            flex: 1;
        }

        .breadcrumb-item {
            cursor: pointer;
            padding: 2px 4px;
            border-radius: 2px;
        }

        .breadcrumb-item:hover {
            background: #3c3c3c;
        }

        .breadcrumb-separator {
            color: #555;
        }

        /* åˆå¹¶çš„å¯æ»šåŠ¨å·¥å…·æ  */
        .toolbar-scrollable {
            background: #2d2d2d;
            border-bottom: 1px solid #3c3c3c;
            padding: 6px 12px;
            display: flex;
            gap: 8px;
            align-items: center;
            overflow-x: auto;
            overflow-y: hidden;
            white-space: nowrap;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: thin;
            scrollbar-color: #555 #2d2d2d;
        }

        .toolbar-scrollable::-webkit-scrollbar {
            height: 6px;
        }

        .toolbar-scrollable::-webkit-scrollbar-track {
            background: #2d2d2d;
        }

        .toolbar-scrollable::-webkit-scrollbar-thumb {
            background-color: #555;
            border-radius: 3px;
        }

        .menu-item {
            flex-shrink: 0;
        }

        .toolbar-group {
            flex-shrink: 0;
        }

        @media (max-width: 768px) {
            .toolbar-scrollable {
                padding: 4px 8px;
                gap: 4px;
            }

            .breadcrumb {
                font-size: 11px;
                gap: 2px;
            }

            .content-header {
                padding: 4px 8px;
                gap: 4px;
            }

            .content-header .actions {
                gap: 4px;
            }

            .content-header .actions button {
                padding: 4px 6px;
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <header>
        <button class="toggle-sidebar-btn" id="toggleSidebar">â˜°</button>
        <h1>PVF Web Browser</h1>
        <button id="openBtn" class="desktop-only">æ‰“å¼€</button>
        <button id="saveBtn" disabled class="desktop-only">ä¿å­˜</button>
    </header>

    <div class="container">
        <div class="sidebar-overlay" id="sidebarOverlay"></div>
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <input type="text" id="searchInput" placeholder="æœç´¢...">
            </div>
            <div class="sidebar-tabs">
                <div class="sidebar-tab active" data-tab="tree">ç›®å½•</div>
                <div class="sidebar-tab" data-tab="search">æœç´¢ç»“æœ</div>
            </div>
            <div class="batch-actions" id="batchActions">
                <div class="selected-count">å·²é€‰æ‹© <span id="selectedCount">0</span> ä¸ªæ–‡ä»¶</div>
                <button id="batchExtractBtn">æ‰¹é‡æå–</button>
                <button id="clearSelectionBtn">æ¸…é™¤é€‰æ‹©</button>
            </div>
            <div class="file-tree" id="fileTree">
                <div style="padding: 20px; text-align: center; color: #858585;">
                    åŠ è½½ä¸­...
                </div>
            </div>
            <div class="search-results" id="searchResults" style="display: none;">
                <div style="padding: 20px; text-align: center; color: #858585;">
                    ä½¿ç”¨é«˜çº§æœç´¢åŠŸèƒ½æŸ¥æ‰¾æ–‡ä»¶
                </div>
            </div>
        </div>

        <div class="main-content">
            <!-- åˆå¹¶çš„å·¥å…·æ ï¼ˆå¯æ¨ªå‘æ»šåŠ¨ï¼‰ -->
            <div class="toolbar-scrollable" id="toolbarScrollable">
                <!-- èœå•é¡¹ -->
                <div class="menu-item" id="fileMenu">
                    æ–‡ä»¶ â–¾
                    <div class="menu-dropdown" id="pvfFileMenu">
                        <div class="menu-dropdown-empty">åŠ è½½ä¸­...</div>
                    </div>
                </div>
                <div class="menu-item">
                    ä¹¦ç­¾ â–¾
                    <div class="menu-dropdown" id="bookmarkMenu">
                        <div class="menu-dropdown-empty">æš‚æ— ä¹¦ç­¾</div>
                    </div>
                </div>

                <!-- åŠŸèƒ½æŒ‰é’® -->
                <div class="toolbar-group">
                    <button id="addBookmarkBtn" title="æ·»åŠ ä¹¦ç­¾">â­</button>
                    <button id="advancedSearchBtn" title="é«˜çº§æœç´¢">ğŸ”</button>
                    <button id="editBtn" disabled>ç¼–è¾‘</button>
                    <button id="extractBtn" disabled>æå–</button>
                </div>

                <div class="toolbar-group">
                    <button id="batchModeBtn">æ‰¹é‡</button>
                    <button id="toggleWhitespaceBtn" title="æ˜¾ç¤ºç©ºç™½å­—ç¬¦" style="font-size: 12px;">Â¶</button>
                </div>

                <!-- ç¼–ç é€‰æ‹©ï¼ˆæ”¾åœ¨æœ€åï¼‰ -->
                <div class="toolbar-group" style="border-right: none;">
                    <label>ç¼–ç :</label>
                    <select id="encodingSelect">
                        <option value="AUTO">è‡ªåŠ¨</option>
                        <option value="KR">éŸ©æ–‡</option>
                        <option value="TW" selected>ç¹ä½“</option>
                        <option value="CN">ç®€ä½“</option>
                        <option value="JP">æ—¥æ–‡</option>
                        <option value="UTF8">UTF8</option>
                    </select>
                </div>
            </div>

            <!-- æ–‡ä»¶è·¯å¾„æ˜¾ç¤º -->
            <div class="content-header">
                <div class="breadcrumb" id="breadcrumb" style="font-family: 'Consolas', monospace; font-size: 12px;">æœªé€‰æ‹©æ–‡ä»¶</div>
                <div class="actions">
                    <button id="copyPathBtn" title="å¤åˆ¶æ–‡ä»¶è·¯å¾„" disabled>ğŸ“‹</button>
                    <button id="locateDirBtn" title="å®šä½åˆ°ç›®å½•" disabled>ğŸ“</button>
                </div>
            </div>

            <!-- æ ‡ç­¾é¡µæ  -->
            <div class="tabs-bar" id="tabsBar">
                <div class="tabs-container" id="tabsContainer">
                    <!-- æ ‡ç­¾é¡µä¼šåœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                </div>
            </div>

            <div class="file-viewer" id="fileViewer">
                <div class="empty">é€‰æ‹©ä¸€ä¸ªæ–‡ä»¶æŸ¥çœ‹å†…å®¹</div>
            </div>
        </div>
    </div>

    <div class="status-bar" id="statusBar">
        å°±ç»ª
    </div>

    <!-- æ‰“å¼€æ–‡ä»¶å¯¹è¯æ¡† -->
    <div class="modal" id="openModal">
        <div class="modal-content">
            <div class="modal-header">æ‰“å¼€ PVF æ–‡ä»¶</div>
            <div class="modal-body">
                <input type="text" id="filePathInput" placeholder="è¾“å…¥ PVF æ–‡ä»¶è·¯å¾„">
                <div style="font-size: 12px; color: #858585; margin-top: 5px;">
                    æç¤º: è¾“å…¥æœåŠ¡å™¨ä¸Šçš„ç»å¯¹è·¯å¾„
                </div>
            </div>
            <div class="modal-footer">
                <button id="cancelOpenBtn">å–æ¶ˆ</button>
                <button id="confirmOpenBtn">æ‰“å¼€</button>
            </div>
        </div>
    </div>

    <!-- é«˜çº§æœç´¢å¯¹è¯æ¡† -->
    <div class="modal" id="searchModal">
        <div class="modal-content search-modal-content">
            <div class="modal-header">
                ğŸ” é«˜çº§æœç´¢
            </div>
            <div class="modal-body">
                <div class="search-field-group">
                    <label for="searchTypeSelect" class="search-label">
                        <span class="search-icon">ğŸ“</span>
                        æœç´¢ç±»å‹
                    </label>
                    <select id="searchTypeSelect" class="search-select">
                        <option value="filename">æ–‡ä»¶å</option>
                        <option value="name">è„šæœ¬åç§°</option>
                        <option value="number">æ•°å­—</option>
                        <option value="string">å­—ç¬¦ä¸²</option>
                        <option value="content">è„šæœ¬å†…å®¹</option>
                    </select>
                </div>

                <div class="search-field-group">
                    <label for="searchKeywordInput" class="search-label">
                        <span class="search-icon">ğŸ”¤</span>
                        æœç´¢å…³é”®è¯
                    </label>
                    <input type="text" id="searchKeywordInput" class="search-input" placeholder="è¾“å…¥å…³é”®è¯...">
                </div>

                <div class="search-options-group">
                    <label class="search-section-label">æœç´¢é€‰é¡¹</label>
                    <div class="search-checkbox-grid">
                        <label class="search-checkbox-label">
                            <input type="checkbox" id="searchStartMatch">
                            <span class="checkbox-text">å¼€å¤´åŒ¹é…</span>
                        </label>
                        <label class="search-checkbox-label">
                            <input type="checkbox" id="searchUseRegex">
                            <span class="checkbox-text">æ­£åˆ™è¡¨è¾¾å¼</span>
                        </label>
                        <label class="search-checkbox-label">
                            <input type="checkbox" id="searchCaseSensitive">
                            <span class="checkbox-text">åŒºåˆ†å¤§å°å†™</span>
                        </label>
                    </div>
                </div>
            </div>
            <div class="modal-footer search-footer">
                <button id="cancelSearchBtn" class="search-btn cancel-btn">å–æ¶ˆ</button>
                <button id="confirmSearchBtn" class="search-btn search-confirm-btn">
                    ğŸ” å¼€å§‹æœç´¢
                </button>
            </div>
        </div>
    </div>

    <!-- æå–æ–‡ä»¶å¯¹è¯æ¡† -->
    <div id="extractModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">ä¸‹è½½æ–‡ä»¶</div>
            <div class="modal-body">
                <p>å½“å‰æ–‡ä»¶ï¼š<span id="extractFileName"></span></p>
                <p style="color: #858585; font-size: 13px;">ç‚¹å‡»ç¡®è®¤å°†ç›´æ¥ä¸‹è½½æ–‡ä»¶åˆ°æ‚¨çš„è®¾å¤‡</p>
            </div>
            <div class="modal-footer">
                <button id="cancelExtractBtn">å–æ¶ˆ</button>
                <button id="confirmExtractBtn">ä¸‹è½½</button>
            </div>
        </div>
    </div>

    <!-- ä¿å­˜æ–‡ä»¶å¯¹è¯æ¡† -->
    <div class="modal" id="saveModal">
        <div class="modal-content">
            <div class="modal-header">ä¿å­˜ PVF æ–‡ä»¶</div>
            <div class="modal-body">
                <input type="text" id="savePathInput" placeholder="è¾“å…¥ä¿å­˜è·¯å¾„">
            </div>
            <div class="modal-footer">
                <button id="cancelSaveBtn">å–æ¶ˆ</button>
                <button id="confirmSaveBtn">ä¿å­˜</button>
            </div>
        </div>
    </div>

    <!-- ç¼–è¾‘æ–‡ä»¶å¯¹è¯æ¡† -->
    <div class="modal" id="editModal">
        <div class="modal-content" style="max-width: 95%;">
            <div class="modal-header">ç¼–è¾‘æ–‡ä»¶: <span id="editFileName"></span></div>
            <div class="modal-body">
                <textarea id="editFileContent" spellcheck="false"></textarea>
            </div>
            <div class="modal-footer">
                <button id="cancelEditBtn">å–æ¶ˆ</button>
                <button id="confirmEditBtn">ä¿å­˜åˆ° PVF</button>
            </div>
        </div>
    </div>

    <!-- æ‰¹é‡æå–å¯¹è¯æ¡† -->
    <div class="modal" id="batchExtractModal">
        <div class="modal-content">
            <div class="modal-header">æ‰¹é‡æå–æ–‡ä»¶</div>
            <div class="modal-body">
                <p>å°†æå– <span id="batchExtractCount">0</span> ä¸ªæ–‡ä»¶</p>
                <div style="margin-bottom: 15px;">
                    <label>ç›®æ ‡è·¯å¾„ï¼š</label>
                    <input type="text" id="batchDestPathInput" style="width: 100%; margin-top: 5px;" placeholder="è¾“å…¥ç›®æ ‡è·¯å¾„">
                </div>
            </div>
            <div class="modal-footer">
                <button id="cancelBatchExtractBtn">å–æ¶ˆ</button>
                <button id="confirmBatchExtractBtn">æå–</button>
            </div>
        </div>
    </div>

    <!-- ç¼–è¾‘ä¹¦ç­¾å¯¹è¯æ¡† -->
    <div class="modal" id="editBookmarkModal">
        <div class="modal-content">
            <div class="modal-header">ç¼–è¾‘ä¹¦ç­¾åˆ«å</div>
            <div class="modal-body">
                <p>æ–‡ä»¶è·¯å¾„ï¼š<span id="editBookmarkPath"></span></p>
                <div style="margin-bottom: 15px;">
                    <label>åˆ«åï¼š</label>
                    <input type="text" id="editBookmarkName" style="width: 100%; margin-top: 5px;">
                </div>
            </div>
            <div class="modal-footer">
                <button id="cancelEditBookmarkBtn">å–æ¶ˆ</button>
                <button id="confirmEditBookmarkBtn">ä¿å­˜</button>
            </div>
        </div>
    </div>

    <!-- åŠ è½½æç¤º -->
    <div class="loading" id="loading">å¤„ç†ä¸­...</div>

<!-- è¯­æ³•é«˜äº® - æœ¬åœ°åŠ è½½ -->
    <script>
        // æœ¬åœ°åŠ è½½Prism.js
        function loadPrism() {
            console.log('Loading Prism.js from local...');
            const script = document.createElement('script');
            script.src = 'libs/prism.min.js';
            script.onload = function() {
                console.log('Prism.js loaded successfully from local');
                // æ³¨å†ŒPVFè¯­è¨€
                if (typeof Prism !== 'undefined') {
                    Prism.languages.pvf = {
                        'section': { pattern: /\[[^\]]*\]/, greedy: true, inside: {
                            'punctuation': /\[|\]/,
                            'keyword': /[^\]\[\s]+/
                        }},
                        'string': { pattern: /`(?:\\`|[^`])*`/, greedy: true },
                        'comment': { pattern: /#.*/, greedy: true },
                        'number': { pattern: /\b\d+\b/, greedy: true },
                        'operator': /[=+\-*/%<>!&|^~?:,]/,
                        'identifier': { pattern: /\b[a-zA-Z_][a-zA-Z0-9_]*\b/, greedy: true }
                    };
                    
                    // æ³¨å†Œ Squirrel è¯­è¨€ï¼ˆ.nut æ–‡ä»¶ï¼‰
                    Prism.languages.squirrel = {
                        'comment': [
                            { pattern: /\/\/.*/, greedy: true },
                            { pattern: /\/\*[\s\S]*?\*\//, greedy: true }
                        ],
                        'string': [
                            { pattern: /'(?:\\'|[^'])*'/, greedy: true },
                            { pattern: /"(?:\\"|[^"])*"/, greedy: true },
                            { pattern: /@'(?:\\'|[^'])*'/, greedy: true },
                            { pattern: /@"(?:\\"|[^"])*"/, greedy: true }
                        ],
                        'class-name': {
                            pattern: /(\bclass\s+)[a-zA-Z_][a-zA-Z0-9_]*/,
                            lookbehind: true
                        },
                        'keyword': /\b(?:local|function|return|if|else|for|while|do|break|continue|switch|case|default|class|extends|constructor|this|static|null|true|false|typeof|instanceof|delete|in|clone|resume|yield|throw|try|catch|finally)\b/,
                        'boolean': /\b(?:true|false)\b/,
                        'null': /\bnull\b/,
                        'number': [
                            { pattern: /\b0x[0-9a-fA-F]+\b/, greedy: true },
                            { pattern: /\b\d+(?:\.\d+)?(?:[eE][+-]?\d+)?\b/, greedy: true }
                        ],
                        'function': /\b[a-zA-Z_][a-zA-Z0-9_]*\s*\(/,
                        'operator': /->|\+\+|--|[-+*/%&|^~!=<>]=?|&&|\|\|[?:]/,
                        'punctuation': /[{}[\](),.;:]/
                    };
                    
                    console.log('PVF and Squirrel languages registered');
                    
                    // å¦‚æœå½“å‰æœ‰æ–‡ä»¶åœ¨æ˜¾ç¤ºï¼Œé‡æ–°åº”ç”¨é«˜äº®
                    const preElement = document.querySelector('#fileViewer pre');
                    if (preElement) {
                        console.log('Re-applying syntax highlighting to current file');
                        Prism.highlightElement(preElement);
                    }
                } else {
                    console.error('Prism is not defined after loading');
                }
            };
            script.onerror = function() {
                console.error('Failed to load Prism.js from local file');
            };
            document.head.appendChild(script);
        }
        // é¡µé¢åŠ è½½å®Œæˆåå†åŠ è½½Prism
        window.addEventListener('load', loadPrism);
    </script>
    <script>
        console.log('Main script starting...');
        
        // ç®€å•æµ‹è¯•
        try {
            console.log('DOM ready:', document.readyState);
            console.log('fileTree exists:', !!document.getElementById('fileTree'));
        } catch (e) {
            console.error('Init test failed:', e);
        }
        
        const toggleSidebarBtn = document.getElementById('toggleSidebar');
        const sidebar = document.getElementById('sidebar');
        const sidebarOverlay = document.getElementById('sidebarOverlay');
        const openBtn = document.getElementById('openBtn');
        const saveBtn = document.getElementById('saveBtn');
        const editBtn = document.getElementById('editBtn');
        const extractBtn = document.getElementById('extractBtn');
        const batchModeBtn = document.getElementById('batchModeBtn');
        const addBookmarkBtn = document.getElementById('addBookmarkBtn');
        const advancedSearchBtn = document.getElementById('advancedSearchBtn');
        const encodingSelect = document.getElementById('encodingSelect');
        const searchInput = document.getElementById('searchInput');
        const fileTree = document.getElementById('fileTree');
        const fileViewer = document.getElementById('fileViewer');
        const breadcrumb = document.getElementById('breadcrumb');
        const statusBar = document.getElementById('statusBar');
        const loading = document.getElementById('loading');

        const openModal = document.getElementById('openModal');
        const extractModal = document.getElementById('extractModal');
        const saveModal = document.getElementById('saveModal');
        const editModal = document.getElementById('editModal');
        const batchExtractModal = document.getElementById('batchExtractModal');
        const searchModal = document.getElementById('searchModal');
        const batchActions = document.getElementById('batchActions');
        const copyPathBtn = document.getElementById('copyPathBtn');
        const locateDirBtn = document.getElementById('locateDirBtn');

        let currentFile = null;
        let currentFilePath = null;
        let currentPath = '';
        let pathHistory = [];
        let batchMode = false;
        let selectedFiles = new Set();
        let bookmarks = [];

        // åç§°é¢„è§ˆç¼“å­˜ï¼Œé¿å…é‡å¤è¯·æ±‚
        const namePreviewCache = new Map();
        const namePreviewPromises = new Map(); // ç”¨äºç¼“å­˜æ­£åœ¨è¿›è¡Œçš„è¯·æ±‚

        // æ ‡ç­¾é¡µç®¡ç†
        let tabs = [];
        let activeTabId = null;

        // æ–‡ä»¶å†…å®¹ç¼“å­˜
        let fileContentCache = new Map(); // key -> { content, encoding, lines, timestamp }

        // åˆ›å»ºæ–°æ ‡ç­¾é¡µ
        function createTab(key) {
            const tabId = Date.now().toString();
            const fileName = key.split('/').pop();

            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
            const existingTab = tabs.find(t => t.key === key);
            if (existingTab) {
                switchToTab(existingTab.id);
                return existingTab.id;
            }

            const tab = {
                id: tabId,
                key: key,
                name: fileName,
                isActive: true,
                isLoaded: false
            };

            // å°†å…¶ä»–æ ‡ç­¾è®¾ä¸ºéæ´»åŠ¨
            tabs.forEach(t => t.isActive = false);
            tabs.push(tab);
            activeTabId = tabId;

            renderTabs();
            return tabId;
        }

        // åˆ‡æ¢æ ‡ç­¾é¡µ
        function switchToTab(tabId) {
            const tab = tabs.find(t => t.id === tabId);
            if (!tab) return;

            tabs.forEach(t => t.isActive = t.id === tabId);
            activeTabId = tabId;

            currentFile = tab.key;
            updateBreadcrumb(tab.key);

            // æ£€æŸ¥ç¼“å­˜
            const cached = fileContentCache.get(tab.key);
            if (cached) {
                // ä½¿ç”¨ç¼“å­˜æ¸²æŸ“
                renderFileFromCache(tab.key, cached);
                tab.isLoaded = true;
            } else {
                // åŠ è½½æ–‡ä»¶å†…å®¹
                loadFileContent(tab.key);
            }

            renderTabs();
        }

        // ä»ç¼“å­˜æ¸²æŸ“æ–‡ä»¶å†…å®¹
        function renderFileFromCache(key, cached) {
            const ext = key.split('.').pop().toLowerCase();
            const languageClass = getLanguageClass(ext);
            const lines = cached.lines;
            const lineCount = lines.length;

            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            extractBtn.disabled = false;
            const copyPathBtn = document.getElementById('copyPathBtn');
            const locateDirBtn = document.getElementById('locateDirBtn');
            if (copyPathBtn) copyPathBtn.disabled = false;
            if (locateDirBtn) locateDirBtn.disabled = false;

            const editableExtensions = ['txt', 'nut', 'str', 'lst', 'equ', 'stk', 'ai', 'aic', 'key', 'als', 'act'];
            editBtn.disabled = !editableExtensions.includes(ext);

            // æ ¹æ®æ–‡ä»¶å¤§å°å†³å®šæ˜¯å¦ä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨
            if (lineCount > 500) {
                // ä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨
                initVirtualScroll(lines, languageClass, key, showWhitespaceMode);
            } else {
                // å°æ–‡ä»¶ç›´æ¥æ¸²æŸ“
                let linesHtml = `<div class="code-with-lines ${languageClass}">`;
                let lineNumbersHtml = '<div class="line-numbers">';
                let codeContentHtml = '<div class="code-content">';

                lines.forEach((line, index) => {
                    lineNumbersHtml += `<div class="line-number">${index + 1}</div>`;
                    const displayLine = escapeHtml(line);
                    codeContentHtml += `<div class="code-line">${displayLine}</div>`;
                });

                lineNumbersHtml += '</div>';
                codeContentHtml += '</div>';
                linesHtml += lineNumbersHtml + codeContentHtml + '</div>';

                fileViewer.innerHTML = linesHtml;

                // åº”ç”¨è¯­æ³•é«˜äº®
                applySyntaxHighlighting();

                // åœ¨è¯­æ³•é«˜äº®ååº”ç”¨ç©ºç™½å­—ç¬¦æ˜¾ç¤º
                if (showWhitespaceMode) {
                    applyWhitespaceDisplay(fileViewer);
                }

                // æ·»åŠ è·¯å¾„é“¾æ¥
                addPathLinks(fileViewer);
            }

            updateStatus(`${key.split('/').pop()} (${lineCount} è¡Œ)`);
        }

        // å…³é—­æ ‡ç­¾é¡µ
        function closeTab(tabId, event) {
            event.stopPropagation();

            const tabIndex = tabs.findIndex(t => t.id === tabId);
            if (tabIndex === -1) return;

            const tab = tabs[tabIndex];
            const wasActive = tab.isActive;

            // æ£€æŸ¥æ˜¯å¦è¿˜æœ‰å…¶ä»–æ ‡ç­¾ä½¿ç”¨è¿™ä¸ªæ–‡ä»¶
            const otherTabsWithSameFile = tabs.filter(t => t.key === tab.key && t.id !== tabId);

            // å¦‚æœæ²¡æœ‰å…¶ä»–æ ‡ç­¾ä½¿ç”¨è¿™ä¸ªæ–‡ä»¶ï¼Œæ¸…é™¤ç¼“å­˜
            if (otherTabsWithSameFile.length === 0) {
                fileContentCache.delete(tab.key);
            }

            tabs.splice(tabIndex, 1);

            if (wasActive && tabs.length > 0) {
                // å¦‚æœå…³é—­çš„æ˜¯å½“å‰æ´»åŠ¨æ ‡ç­¾ï¼Œåˆ‡æ¢åˆ°ç›¸é‚»æ ‡ç­¾
                const newActiveIndex = Math.min(tabIndex, tabs.length - 1);
                switchToTab(tabs[newActiveIndex].id);
            } else if (tabs.length === 0) {
                // å¦‚æœæ²¡æœ‰æ ‡ç­¾äº†ï¼Œæ¸…ç©ºæ–‡ä»¶æŸ¥çœ‹å™¨
                currentFile = null;
                fileViewer.innerHTML = '<div class="empty">é€‰æ‹©ä¸€ä¸ªæ–‡ä»¶æŸ¥çœ‹å†…å®¹</div>';
                updateBreadcrumb('');
                activeTabId = null;
            }

            // æ¸…ç†æ—§ç¼“å­˜ï¼ˆä¿ç•™æœ€è¿‘10ä¸ªæ–‡ä»¶ï¼‰
            if (fileContentCache.size > 10) {
                const entries = Array.from(fileContentCache.entries());
                entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
                const toDelete = entries.slice(0, entries.length - 10);
                toDelete.forEach(([key]) => fileContentCache.delete(key));
            }

            renderTabs();
        }

        // æ¸²æŸ“æ ‡ç­¾é¡µ
        function renderTabs() {
            const container = document.getElementById('tabsContainer');
            if (!container) return;

            if (tabs.length === 0) {
                container.innerHTML = '';
                return;
            }

            container.innerHTML = tabs.map(tab => `
                <div class="tab ${tab.isActive ? 'active' : ''}" data-tab-id="${tab.id}" onclick="switchToTab('${tab.id}')">
                    <span class="tab-title">${tab.name}</span>
                    <span class="tab-close" onclick="closeTab('${tab.id}', event)">Ã—</span>
                </div>
            `).join('');
        }

        // å®šä½ä¸‹æ‹‰èœå•
        function positionDropdown(menuItem, dropdown) {
            const rect = menuItem.getBoundingClientRect();
            dropdown.style.top = (rect.bottom) + 'px';
            dropdown.style.left = rect.left + 'px';
            dropdown.style.background = '#252526';
            dropdown.style.border = '1px solid #3c3c3c';
        }

        // æ¸²æŸ“ä¹¦ç­¾èœå•
        function renderBookmarks() {
            const container = document.getElementById('bookmarkMenu');
            const menuItem = document.querySelectorAll('.menu-item')[1]; // ä¹¦ç­¾èœå•æ˜¯ç¬¬äºŒä¸ª
            console.log('renderBookmarks called, bookmarks:', bookmarks);
            
            if (!container || !menuItem) {
                console.error('bookmarkMenu or menu-item element not found');
                return;
            }

            // å®šä½ä¸‹æ‹‰èœå•
            positionDropdown(menuItem, container);
            
            if (bookmarks.length === 0) {
                container.innerHTML = '<div class="menu-dropdown-empty">æš‚æ— ä¹¦ç­¾</div>';
            } else {
                let html = '';
                bookmarks.forEach(bookmark => {
                    html += `
                        <div class="menu-dropdown-item" data-key="${bookmark.key}">
                            <div style="flex: 1;">
                                <div style="font-weight: 500;">${bookmark.name}</div>
                                <div style="font-size: 11px; color: #858585;">${bookmark.key}</div>
                            </div>
                            <div style="display: flex; gap: 4px;">
                                <button class="delete-btn" onclick="event.stopPropagation(); editBookmark('${bookmark.key}')">âœ</button>
                                <button class="delete-btn" onclick="event.stopPropagation(); removeBookmark('${bookmark.key}')">âœ•</button>
                            </div>
                        </div>
                    `;
                });

                container.innerHTML = html;
                console.log('Bookmark menu updated with', bookmarks.length, 'items');

                // æ·»åŠ ç‚¹å‡»äº‹ä»¶
                container.querySelectorAll('.menu-dropdown-item').forEach(item => {
                    item.addEventListener('click', (e) => {
                        if (e.target.tagName !== 'BUTTON') {
                            const key = item.dataset.key;
                            loadFileContent(key);
                        }
                    });
                });
            }
        }

        // ä»æœåŠ¡å™¨åŠ è½½ PVF æ–‡ä»¶åˆ—è¡¨
        async function loadPvfFiles() {
            console.log('loadPvfFiles called');
            try {
                const response = await fetch('/api/pvf-files');
                console.log('PVF files API response status:', response.status);
                const data = await response.json();
                console.log('PVF files data:', data);
                renderPvfFileMenu(data.files || []);
            } catch (error) {
                console.error('åŠ è½½ PVF æ–‡ä»¶åˆ—è¡¨å¤±è´¥:', error);
                const container = document.getElementById('pvfFileMenu');
                if (container) {
                    container.innerHTML = '<div class="menu-dropdown-empty">åŠ è½½å¤±è´¥</div>';
                }
            }
        }

        // æ¸²æŸ“ PVF æ–‡ä»¶èœå•
        function renderPvfFileMenu(files) {
            console.log('renderPvfFileMenu called with files:', files);
            const container = document.getElementById('pvfFileMenu');
            const menuItem = document.getElementById('fileMenu');

            if (!container) {
                console.error('pvfFileMenu element not found');
                return;
            }
            if (!menuItem) {
                console.error('fileMenu element not found');
                return;
            }

            positionDropdown(menuItem, container);

            if (!files || files.length === 0) {
                container.innerHTML = '<div class="menu-dropdown-empty">æš‚æ—  PVF æ–‡ä»¶</div>';
                return;
            }

            // å…‹éš†èŠ‚ç‚¹ä»¥ç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨
            const newContainer = container.cloneNode(false);
            container.parentNode.replaceChild(newContainer, container);
            const newContainerId = document.getElementById('pvfFileMenu');

            newContainerId.innerHTML = files.map(file => {
                // ç®€åŒ–é€»è¾‘ï¼šä¸ä¾èµ–currentModelåˆ¤æ–­å½“å‰æ–‡ä»¶
                return `
                    <div class="menu-dropdown-item" data-file-path="${encodeURIComponent(file.path)}">
                        ${file.name}
                    </div>
                `;
            }).join('');

            // æ·»åŠ ç‚¹å‡»äº‹ä»¶ - ä½¿ç”¨äº‹ä»¶å§”æ‰˜
            newContainerId.addEventListener('click', (e) => {
                const item = e.target.closest('.menu-dropdown-item');
                if (item) {
                    e.stopPropagation();
                    e.preventDefault();
                    const filePath = decodeURIComponent(item.dataset.filePath);
                    console.log('PVF file clicked:', filePath);
                    openPvfFileFromMenu(filePath);
                }
            });

            console.log('PVF file menu rendered with', files.length, 'files');
        }

        // ä»èœå•æ‰“å¼€ PVF æ–‡ä»¶
        async function openPvfFileFromMenu(filePath) {
            console.log('openPvfFileFromMenu called with filePath:', filePath);
            if (!confirm('ç¡®å®šè¦æ‰“å¼€æ–°çš„ PVF æ–‡ä»¶å—ï¼Ÿè¿™å°†å…³é—­å½“å‰æ–‡ä»¶ã€‚')) {
                return;
            }

            showLoading(true);
            try {
                const response = await fetch('/api/open', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ filePath })
                });

                const data = await response.json();
                if (data.success) {
                    // æ¸…ç©ºå½“å‰çŠ¶æ€
                    tabs = [];
                    activeTabId = null;
                    currentFile = null;
                    fileContentCache.clear();
                    namePreviewCache.clear();
                    namePreviewPromises.clear();

                    // é‡æ–°åŠ è½½æ–‡ä»¶æ ‘å’Œä¹¦ç­¾
                    loadFiles();
                    loadBookmarks();

                    updateStatus('å·²æ‰“å¼€ PVF æ–‡ä»¶');
                } else {
                    alert('æ‰“å¼€æ–‡ä»¶å¤±è´¥: ' + data.error);
                }
            } catch (error) {
                console.error('æ‰“å¼€æ–‡ä»¶å¤±è´¥:', error);
                alert('æ‰“å¼€æ–‡ä»¶å¤±è´¥: ' + error);
            } finally {
                showLoading(false);
            }
        }

        // ä»æœåŠ¡å™¨åŠ è½½ä¹¦ç­¾
        async function loadBookmarks() {
            try {
                console.log('Loading bookmarks from server...');
                const response = await fetch('/api/bookmarks');
                const data = await response.json();
                console.log('Bookmarks data received:', data);
                bookmarks = data.bookmarks || [];
                console.log('Bookmarks array:', bookmarks);
                renderBookmarks();
            } catch (error) {
                console.error('åŠ è½½ä¹¦ç­¾å¤±è´¥:', error);
                bookmarks = [];
                renderBookmarks();
            }
        }

        // ä¿å­˜ä¹¦ç­¾åˆ°æœåŠ¡å™¨
        async function saveBookmarks() {
            try {
                const response = await fetch('/api/bookmarks', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ bookmarks })
                });
                const data = await response.json();
                if (!data.success) {
                    console.error('ä¿å­˜ä¹¦ç­¾å¤±è´¥:', data.error);
                }
            } catch (error) {
                console.error('ä¿å­˜ä¹¦ç­¾å¤±è´¥:', error);
            }
        }

        function showLoading(show) {
            loading.classList.toggle('show', show);
        }

        async function performAdvancedSearch() {
            const searchType = document.getElementById('searchTypeSelect').value;
            const keyword = document.getElementById('searchKeywordInput').value.trim();
            const startMatch = document.getElementById('searchStartMatch').checked;
            const useRegex = document.getElementById('searchUseRegex').checked;
            const caseSensitive = document.getElementById('searchCaseSensitive').checked;

            if (!keyword) {
                alert('è¯·è¾“å…¥æœç´¢å…³é”®è¯');
                return;
            }

            hideModal(searchModal);
            showLoading(true);
            updateStatus('æ­£åœ¨æœç´¢...');

            try {
                const params = new URLSearchParams({
                    type: searchType,
                    keyword: keyword,
                    startMatch: startMatch,
                    useRegex: useRegex,
                    caseSensitive: caseSensitive
                });

                const response = await fetch(`/api/advanced-search?${params}`);
                const data = await response.json();

                // åˆ‡æ¢åˆ°æœç´¢ç»“æœæ ‡ç­¾é¡µ
                document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
                document.querySelector('.sidebar-tab[data-tab="search"]').classList.add('active');
                document.getElementById('fileTree').style.display = 'none';
                document.getElementById('searchResults').style.display = 'block';

                if (data.results && data.results.length > 0) {
                    // æ˜¾ç¤ºæœç´¢ç»“æœ
                    showSearchResults(data.results);
                    
                    // åœ¨ç§»åŠ¨ç«¯æ˜¾ç¤ºä¾§è¾¹æ 
                    if (window.innerWidth <= 768) {
                        toggleSidebar(true);
                    }
                    
                    updateStatus(`æ‰¾åˆ° ${data.results.length} ä¸ªåŒ¹é…é¡¹`);
                } else {
                    document.getElementById('searchResults').innerHTML = '<div style="padding: 20px; text-align: center; color: #858585;">æœªæ‰¾åˆ°åŒ¹é…çš„æ–‡ä»¶</div>';
                    updateStatus('æœªæ‰¾åˆ°åŒ¹é…é¡¹');
                }
            } catch (error) {
                console.error('æœç´¢å¤±è´¥:', error);
                document.getElementById('searchResults').innerHTML = '<div style="padding: 20px; text-align: center; color: #ff6b6b;">æœç´¢å¤±è´¥</div>';
                updateStatus('æœç´¢å¤±è´¥');
            } finally {
                showLoading(false);
            }
        }

        function updateStatus(message) {
            statusBar.textContent = message;
        }

        function showModal(modal) {
            modal.classList.add('show');
        }

        function hideModal(modal) {
            modal.classList.remove('show');
        }

        function toggleSidebar(show) {
            if (show) {
                sidebar.classList.remove('collapsed');
                sidebarOverlay.classList.add('show');
            } else {
                sidebar.classList.add('collapsed');
                sidebarOverlay.classList.remove('show');
            }
        }

        function updateBreadcrumb(path) {
            if (!path) {
                breadcrumb.textContent = 'æœªé€‰æ‹©æ–‡ä»¶';
                return;
            }
            breadcrumb.textContent = path;
        }

        async function openPvfFile() {
            const filePath = document.getElementById('filePathInput').value.trim();
            if (!filePath) {
                alert('è¯·è¾“å…¥æ–‡ä»¶è·¯å¾„');
                return;
            }

            showLoading(true);
            updateStatus('æ­£åœ¨æ‰“å¼€ PVF æ–‡ä»¶...');

            try {
                const response = await fetch('/api/open', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        filePath,
                        encodingMode: encodingSelect.value
                    })
                });

                const data = await response.json();
                
                if (data.success) {
                    currentFilePath = filePath;
                    saveBtn.disabled = false;
                    currentPath = '';
                    pathHistory = [];
                    loadFiles('');
                    updateStatus(`å·²æ‰“å¼€: ${filePath.split('/').pop()}`);
                } else {
                    alert('æ‰“å¼€æ–‡ä»¶å¤±è´¥: ' + data.error);
                }
            } catch (error) {
                alert('æ‰“å¼€æ–‡ä»¶å¤±è´¥: ' + error.message);
            } finally {
                showLoading(false);
                hideModal(openModal);
            }
        }

        async function loadFiles(path = '') {
            console.log('loadFiles called with path:', path);
            currentPath = path;
            currentFile = null; // æ¸…é™¤å½“å‰æ–‡ä»¶
            updateBreadcrumb(path);

            // ç¦ç”¨è·¯å¾„æ“ä½œæŒ‰é’®
            if (copyPathBtn) copyPathBtn.disabled = true;
            if (locateDirBtn) locateDirBtn.disabled = true;

            try {
                console.log('Fetching /api/files with path:', path);
                const response = await fetch(`/api/files?path=${encodeURIComponent(path)}`);
                const data = await response.json();
                console.log('Received data:', data);

                if (data.error) {
                    console.error('åŠ è½½æ–‡ä»¶åˆ—è¡¨å¤±è´¥:', data.error);
                    fileTree.innerHTML = `<div style="padding: 20px; text-align: center; color: #ff6b6b;">åŠ è½½å¤±è´¥: ${data.error}</div>`;
                    return;
                }

                console.log('Rendering file tree with', data.files?.length || 0, 'files');
                renderFileTree(data.files, path);
            } catch (error) {
                console.error('åŠ è½½æ–‡ä»¶åˆ—è¡¨å¤±è´¥:', error);
                fileTree.innerHTML = '<div style="padding: 20px; text-align: center; color: #ff6b6b;">åŠ è½½å¤±è´¥: æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨</div>';
            }
        }

        function renderFileTree(files, currentPath) {
            if (files.length === 0) {
                fileTree.innerHTML = '<div style="padding: 20px; text-align: center; color: #858585;">æ–‡ä»¶å¤¹ä¸ºç©º</div>';
                return;
            }

            // åˆ†ç¦»æ–‡ä»¶å¤¹å’Œæ–‡ä»¶
            const folders = files.filter(f => !f.isFile);
            const fileItems = files.filter(f => f.isFile);

            // æ„å»ºæ ‘å½¢ç»“æ„HTML
            let html = '';
            
            // æ·»åŠ è¿”å›æŒ‰é’®ï¼ˆå¦‚æœä¸æ˜¯æ ¹ç›®å½•ï¼‰
            if (currentPath !== '') {
                html += `
                    <div class="file-item back-item" data-path="${currentPath}">
                        <span class="icon">â¬†ï¸</span>
                        <span class="name">è¿”å›ä¸Šä¸€çº§</span>
                    </div>
                `;
            }

            // æ·»åŠ æ–‡ä»¶å¤¹ï¼ˆå¸¦å±•å¼€å›¾æ ‡ï¼‰
            folders.forEach(folder => {
                html += `
                    <div class="file-item folder-item" data-key="${folder.key}" data-is-file="false">
                        <span class="toggle-icon">â–¶</span>
                        <span class="icon">ğŸ“</span>
                        <span class="name">${folder.name}</span>
                    </div>
                    <div class="folder-children" data-parent="${folder.key}" style="display: none; padding-left: 20px;"></div>
                `;
            });

            // æ·»åŠ æ–‡ä»¶
            fileItems.forEach(file => {
                const checkbox = batchMode ? `<div class="checkbox"><input type="checkbox" data-key="${file.key}"></div>` : '';
                html += `
                    <div class="file-item" data-key="${file.key}" data-is-file="true">
                        ${checkbox}
                        <span class="toggle-icon" style="visibility: hidden;"></span>
                        <span class="icon">ğŸ“„</span>
                        <span class="name">${file.name}</span>
                        ${file.size ? `<span class="size">${formatSize(file.size)}</span>` : ''}
                    </div>
                `;
            });

            fileTree.innerHTML = html;

            // æ·»åŠ ç‚¹å‡»äº‹ä»¶
            fileTree.querySelectorAll('.file-item').forEach(item => {
                item.addEventListener('click', async (e) => {
                    const key = item.dataset.key;
                    const isFile = item.dataset.isFile === 'true';
                    const isBack = item.classList.contains('back-item');

                    if (isBack) {
                        // è¿”å›ä¸Šä¸€çº§
                        const parentPath = currentPath.substring(0, currentPath.lastIndexOf('/'));
                        loadFiles(parentPath);
                    } else if (isFile) {
                        // åŠ è½½æ–‡ä»¶å†…å®¹
                        loadFileContent(key);
                    } else {
                        // å±•å¼€/æ”¶èµ·æ–‡ä»¶å¤¹
                        const childrenContainer = fileTree.querySelector(`.folder-children[data-parent="${key}"]`);
                        const toggleIcon = item.querySelector('.toggle-icon');
                        
                        if (childrenContainer.style.display === 'none') {
                            // å±•å¼€
                            toggleIcon.textContent = 'â–¼';
                            childrenContainer.style.display = 'block';
                            
                            // å¦‚æœå­å†…å®¹ä¸ºç©ºï¼ŒåŠ è½½
                            if (childrenContainer.innerHTML.trim() === '') {
                                showLoading(true);
                                try {
                                    const response = await fetch(`/api/files?path=${encodeURIComponent(key)}`);
                                    const data = await response.json();
                                    
                                    if (data.files && data.files.length > 0) {
                                        renderSubTree(data.files, key, childrenContainer);
                                    } else {
                                        childrenContainer.innerHTML = '<div style="padding: 10px; color: #858585;">(ç©ºæ–‡ä»¶å¤¹)</div>';
                                    }
                                } catch (error) {
                                    console.error('åŠ è½½å­ç›®å½•å¤±è´¥:', error);
                                } finally {
                                    showLoading(false);
                                }
                            }
                        } else {
                            // æ”¶èµ·
                            toggleIcon.textContent = 'â–¶';
                            childrenContainer.style.display = 'none';
                        }
                    }
                });
            });
        }

        // æ¸²æŸ“å­æ ‘ï¼ˆç”¨äºå±•å¼€æ–‡ä»¶å¤¹æ—¶ï¼‰
        function renderSubTree(files, parentPath, container) {
            const folders = files.filter(f => !f.isFile);
            const fileItems = files.filter(f => f.isFile);

            let html = '';
            
            folders.forEach(folder => {
                html += `
                    <div class="file-item folder-item" data-key="${folder.key}" data-is-file="false">
                        <span class="toggle-icon">â–¶</span>
                        <span class="icon">ğŸ“</span>
                        <span class="name">${folder.name}</span>
                    </div>
                    <div class="folder-children" data-parent="${folder.key}" style="display: none; padding-left: 20px;"></div>
                `;
            });

            fileItems.forEach(file => {
                html += `
                    <div class="file-item" data-key="${file.key}" data-is-file="true">
                        <span class="toggle-icon" style="visibility: hidden;"></span>
                        <span class="icon">ğŸ“„</span>
                        <span class="name">${file.name}</span>
                        ${file.size ? `<span class="size">${formatSize(file.size)}</span>` : ''}
                    </div>
                `;
            });

            container.innerHTML = html;

            // ä¸ºå­æ ‘æ·»åŠ ç‚¹å‡»äº‹ä»¶
            container.querySelectorAll('.file-item').forEach(item => {
                item.addEventListener('click', async (e) => {
                    e.stopPropagation(); // é˜²æ­¢å†’æ³¡
                    const key = item.dataset.key;
                    const isFile = item.dataset.isFile === 'true';

                    if (isFile) {
                        loadFileContent(key);
                    } else {
                        const childrenContainer = container.querySelector(`.folder-children[data-parent="${key}"]`);
                        const toggleIcon = item.querySelector('.toggle-icon');
                        
                        if (childrenContainer.style.display === 'none') {
                            toggleIcon.textContent = 'â–¼';
                            childrenContainer.style.display = 'block';
                            
                            if (childrenContainer.innerHTML.trim() === '') {
                                showLoading(true);
                                try {
                                    const response = await fetch(`/api/files?path=${encodeURIComponent(key)}`);
                                    const data = await response.json();
                                    
                                    if (data.files && data.files.length > 0) {
                                        renderSubTree(data.files, key, childrenContainer);
                                    } else {
                                        childrenContainer.innerHTML = '<div style="padding: 10px; color: #858585;">(ç©ºæ–‡ä»¶å¤¹)</div>';
                                    }
                                } catch (error) {
                                    console.error('åŠ è½½å­ç›®å½•å¤±è´¥:', error);
                                } finally {
                                    showLoading(false);
                                }
                            }
                        } else {
                            toggleIcon.textContent = 'â–¶';
                            childrenContainer.style.display = 'none';
                        }
                    }
                });
            });
        }

        // è™šæ‹Ÿæ»šåŠ¨ç›¸å…³å˜é‡
        let virtualScrollData = {
            lines: [],
            lineHeight: 19.2, // 12px * 1.6
            visibleLines: 50,
            scrollTop: 0,
            containerHeight: 0,
            languageClass: '',
            showWhitespace: false
        };

        async function loadFileContent(key) {
            // åˆ›å»ºæˆ–åˆ‡æ¢åˆ°æ ‡ç­¾é¡µ
            createTab(key);

            showLoading(true);
            updateStatus('æ­£åœ¨åŠ è½½æ–‡ä»¶å†…å®¹...');

            try {
                const response = await fetch(`/api/file?key=${encodeURIComponent(key)}`);
                const data = await response.json();

                currentFile = key;
                updateBreadcrumb(key); // æ›´æ–°æ–‡ä»¶è·¯å¾„æ˜¾ç¤º
                extractBtn.disabled = false;
                
                // å¯ç”¨è·¯å¾„æ“ä½œæŒ‰é’®
                const copyPathBtn = document.getElementById('copyPathBtn');
                const locateDirBtn = document.getElementById('locateDirBtn');
                if (copyPathBtn) copyPathBtn.disabled = false;
                if (locateDirBtn) locateDirBtn.disabled = false;
                
                // æ£€æŸ¥æ˜¯å¦ä¸ºå¯ç¼–è¾‘çš„æ–‡æœ¬æ–‡ä»¶
                const ext = key.split('.').pop().toLowerCase();
                const editableExtensions = [
                'txt', 'nut', 'str', 'lst', 'equ', 'stk', 'ai', 'aic', 'key', 'als', 'act',
                'chr', 'etc', 'dgn', 'map', 'shp', 'ora', 'atk', 'ui', 'mm', 'mob', 'npc',
                'obj', 'qst', 'til', 'dwm', 'twn'
            ];
                editBtn.disabled = !editableExtensions.includes(ext);

                // æ ¹æ®æ–‡ä»¶æ‰©å±•åç¡®å®šè¯­è¨€ç±»å‹
                const languageClass = getLanguageClass(ext);
                
                // åˆ†å‰²æˆè¡Œï¼ˆä½¿ç”¨åŸå§‹å†…å®¹ï¼‰
                const lines = data.content.split('\n');
                const lineCount = lines.length;

                // ä¿å­˜åˆ°ç¼“å­˜
                fileContentCache.set(key, {
                    content: data.content,
                    encoding: encodingSelect.value,
                    lines: lines,
                    timestamp: Date.now()
                });

                // æ ‡è®°æ ‡ç­¾ä¸ºå·²åŠ è½½
                const currentTab = tabs.find(t => t.key === key);
                if (currentTab) {
                    currentTab.isLoaded = true;
                }

                // åˆ¤æ–­æ˜¯å¦ä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨ï¼ˆè¶…è¿‡500è¡Œä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨ï¼‰
                if (lineCount > 500) {
                    // ä½¿ç”¨è™šæ‹Ÿæ»šåŠ¨
                    initVirtualScroll(lines, languageClass, key, showWhitespaceMode);
                } else {
                    // å°æ–‡ä»¶ç›´æ¥æ¸²æŸ“ï¼Œå¸¦è¡Œå·
                    const lines = data.content.split('\n');
                    let linesHtml = `<div class="code-with-lines ${languageClass}">`;
                    let lineNumbersHtml = '<div class="line-numbers">';
                    let codeContentHtml = '<div class="code-content">';

                    lines.forEach((line, index) => {
                        lineNumbersHtml += `<div class="line-number">${index + 1}</div>`;
                        // ä¸åœ¨è¿™é‡Œæ›¿æ¢ç©ºç™½å­—ç¬¦ï¼Œä¿ç•™åŸå§‹æ–‡æœ¬ç”¨äºè¯­æ³•é«˜äº®
                        const displayLine = escapeHtml(line);
                        codeContentHtml += `<div class="code-line">${displayLine}</div>`;
                    });

                    lineNumbersHtml += '</div>';
                    codeContentHtml += '</div>';
                    linesHtml += lineNumbersHtml + codeContentHtml + '</div>';

                    fileViewer.innerHTML = linesHtml;

                    // åº”ç”¨è¯­æ³•é«˜äº®
                    applySyntaxHighlighting();

                    // åœ¨è¯­æ³•é«˜äº®ååº”ç”¨ç©ºç™½å­—ç¬¦æ˜¾ç¤º
                    if (showWhitespaceMode) {
                        applyWhitespaceDisplay(fileViewer);
                    }

                    // æ·»åŠ è·¯å¾„é“¾æ¥
                    addPathLinks(fileViewer);
                }

                updateStatus(`${key.split('/').pop()} (${lineCount} è¡Œ)`);
            } catch (error) {
                console.error('åŠ è½½æ–‡ä»¶å†…å®¹å¤±è´¥:', error);
                fileViewer.innerHTML = '<div class="empty">åŠ è½½å¤±è´¥</div>';
            } finally {
                showLoading(false);
            }
        }

        function initVirtualScroll(lines, languageClass, fileName, showWhitespace) {
            virtualScrollData.lines = lines;
            virtualScrollData.languageClass = languageClass;
            virtualScrollData.showWhitespace = showWhitespace;
            const totalHeight = lines.length * virtualScrollData.lineHeight;
            
            // åˆ›å»ºè™šæ‹Ÿæ»šåŠ¨å®¹å™¨
            fileViewer.innerHTML = `
                <div class="virtual-scroll-container" id="virtualScrollContainer">
                    <div class="virtual-scroll-content" id="virtualScrollContent" style="height: ${totalHeight}px;"></div>
                    <div class="virtual-scroll-viewport" id="virtualScrollViewport"></div>
                </div>
            `;
            
            const container = document.getElementById('virtualScrollContainer');
            const viewport = document.getElementById('virtualScrollViewport');
            
            // è®¡ç®—å¯è§è¡Œæ•°
            virtualScrollData.containerHeight = fileViewer.clientHeight;
            virtualScrollData.visibleLines = Math.ceil(virtualScrollData.containerHeight / virtualScrollData.lineHeight) + 10; // å¤šæ¸²æŸ“10è¡Œä½œä¸ºç¼“å†²
            
            // åˆå§‹æ¸²æŸ“
            renderVisibleLines(0, 0);
            
            // ç›‘å¬æ»šåŠ¨äº‹ä»¶ï¼ˆåŒ…æ‹¬wheelã€touchã€scrollï¼‰
            let scrollTimeout;
            let savedScrollLeft = 0;
            
            // æ•è·wheeläº‹ä»¶
            container.addEventListener('wheel', (e) => {
                // å‚ç›´æ»šåŠ¨æ—¶ä¿å­˜æ¨ªå‘ä½ç½®
                if (Math.abs(e.deltaY) > Math.abs(e.deltaX)) {
                    savedScrollLeft = container.scrollLeft;
                }
            }, { passive: true });
            
            // ç›‘å¬scrolläº‹ä»¶
            container.addEventListener('scroll', () => {
                // ä¿å­˜æ¨ªå‘æ»šåŠ¨ä½ç½®
                savedScrollLeft = container.scrollLeft;
                
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    renderVisibleLines(container.scrollTop, savedScrollLeft);
                }, 16); // çº¦60fps
            }, { passive: true });
            
            // è§¦æ‘¸äº‹ä»¶å¤„ç†ï¼ˆç§»åŠ¨ç«¯ï¼‰
            let touchStartScrollLeft = 0;
            container.addEventListener('touchstart', (e) => {
                touchStartScrollLeft = container.scrollLeft;
            }, { passive: true });
            
            container.addEventListener('touchend', () => {
                // è§¦æ‘¸ç»“æŸæ—¶ä¿å­˜å½“å‰æ¨ªå‘ä½ç½®
                savedScrollLeft = container.scrollLeft;
            }, { passive: true });
            
            // ç›‘å¬çª—å£å¤§å°å˜åŒ–
            window.addEventListener('resize', () => {
                virtualScrollData.containerHeight = fileViewer.clientHeight;
                virtualScrollData.visibleLines = Math.ceil(virtualScrollData.containerHeight / virtualScrollData.lineHeight) + 10;
                renderVisibleLines(container.scrollTop, container.scrollLeft);
            });
        }

        function renderVisibleLines(scrollTop, savedScrollLeft = 0) {
            const container = document.getElementById('virtualScrollContainer');
            const viewport = document.getElementById('virtualScrollViewport');
            if (!viewport || !container) return;
            
            // å¦‚æœæ²¡æœ‰ä¼ å…¥savedScrollLeftï¼Œä½¿ç”¨å½“å‰å€¼
            if (savedScrollLeft === 0) {
                savedScrollLeft = container.scrollLeft;
            }
            
            const startLine = Math.floor(scrollTop / virtualScrollData.lineHeight);
            const endLine = Math.min(startLine + virtualScrollData.visibleLines, virtualScrollData.lines.length);
            
            // è®¡ç®—è§†å£ä½ç½®
            const viewportTop = startLine * virtualScrollData.lineHeight;
            viewport.style.top = `${viewportTop}px`;
            viewport.style.height = `${(endLine - startLine) * virtualScrollData.lineHeight}px`;
            
            // æ„å»ºHTML
            let linesHtml = '<div class="code-with-lines">';
            let lineNumbersHtml = '<div class="line-numbers">';
            let codeContentHtml = '<div class="code-content">';
            
            for (let i = startLine; i < endLine; i++) {
                const line = virtualScrollData.lines[i] || '';
                lineNumbersHtml += `<div class="line-number">${i + 1}</div>`;

                // ä¸åœ¨è¿™é‡Œæ›¿æ¢ç©ºç™½å­—ç¬¦ï¼Œä¿ç•™åŸå§‹æ–‡æœ¬ç”¨äºè¯­æ³•é«˜äº®
                const displayLine = escapeHtml(line);
                codeContentHtml += `<div class="code-line">${displayLine}</div>`;
            }

            lineNumbersHtml += '</div>';
            codeContentHtml += '</div>';
            linesHtml += lineNumbersHtml + codeContentHtml + '</div>';

            // è®¾ç½®DOMå†…å®¹ï¼ˆè¿™ä¼šé‡ç½®scrollLeftï¼‰
            viewport.innerHTML = linesHtml;
            
            // ç«‹å³æ¢å¤scrollLeftï¼ˆç¬¬ä¸€æ¬¡ï¼‰
            if (savedScrollLeft > 0) {
                container.scrollLeft = savedScrollLeft;
            }

            // åº”ç”¨è¯­æ³•é«˜äº®ï¼ˆä½¿ç”¨requestAnimationFrameé¿å…é˜»å¡UIï¼‰
            if (typeof Prism !== 'undefined') {
                requestAnimationFrame(() => {
                    const codeLines = viewport.querySelectorAll('.code-line');
                    codeLines.forEach((line, index) => {
                        const lineIndex = startLine + index;
                        const originalLine = virtualScrollData.lines[lineIndex] || '';

                        // åªå¯¹åŒ…å«ä»£ç çš„è¡Œè¿›è¡Œé«˜äº®
                        if (originalLine.trim() && !originalLine.startsWith('#')) {
                            try {
                                const lang = virtualScrollData.languageClass.replace('language-', '');
                                const highlighted = Prism.highlight(originalLine, Prism.languages[lang] || Prism.languages.pvf, virtualScrollData.languageClass);
                                line.innerHTML = highlighted;
                            } catch (e) {
                                // é«˜äº®å¤±è´¥ï¼Œä¿æŒåŸæ ·
                            }
                        }
                    });

                    // åœ¨æ‰€æœ‰è¯­æ³•é«˜äº®å®Œæˆåï¼Œåº”ç”¨ç©ºç™½å­—ç¬¦æ˜¾ç¤º
                    if (virtualScrollData.showWhitespace) {
                        applyWhitespaceDisplay(viewport);
                    }

                    // æ·»åŠ è·¯å¾„é“¾æ¥
                    addPathLinks(viewport);
                    
                    // ç¬¬äºŒæ¬¡æ¢å¤scrollLeftï¼ˆåœ¨DOMæ“ä½œåï¼‰
                    if (savedScrollLeft > 0) {
                        requestAnimationFrame(() => {
                            container.scrollLeft = savedScrollLeft;
                            
                            // ç¬¬ä¸‰æ¬¡æ¢å¤scrollLeftï¼ˆç¡®ä¿ç§»åŠ¨ç«¯ä¹Ÿèƒ½æ­£ç¡®æ¢å¤ï¼‰
                            requestAnimationFrame(() => {
                                if (Math.abs(container.scrollLeft - savedScrollLeft) > 1) {
                                    container.scrollLeft = savedScrollLeft;
                                }
                            });
                        });
                    }
                });
            }
        }

        function applySyntaxHighlighting() {
            if (typeof Prism !== 'undefined') {
                // æŸ¥æ‰¾ä»£ç è¡Œå…ƒç´ 
                const codeLines = fileViewer.querySelectorAll('.code-line');

                if (codeLines.length > 0) {
                    // ä½¿ç”¨ä¸è™šæ‹Ÿæ»šåŠ¨ç›¸åŒçš„é€è¡Œé«˜äº®æ–¹å¼
                    codeLines.forEach((line) => {
                        const originalLine = line.textContent || '';

                        // åªå¯¹åŒ…å«ä»£ç çš„è¡Œè¿›è¡Œé«˜äº®
                        if (originalLine.trim() && !originalLine.startsWith('#')) {
                            try {
                                // ä»fileViewerè·å–language class
                                const langElement = fileViewer.querySelector('[class*="language-"]');
                                if (langElement) {
                                    const langClass = Array.from(langElement.classList).find(cls => cls.startsWith('language-'));
                                    if (langClass) {
                                        const lang = langClass.replace('language-', '');
                                        const highlighted = Prism.highlight(originalLine, Prism.languages[lang] || Prism.languages.pvf, langClass);
                                        line.innerHTML = highlighted;
                                    }
                                }
                            } catch (e) {
                                // é«˜äº®å¤±è´¥ï¼Œä¿æŒåŸæ ·
                            }
                        }
                    });
                } else {
                    // é™çº§æ–¹æ¡ˆï¼šæŸ¥æ‰¾preå…ƒç´ ï¼ˆå…¼å®¹æ—§ä»£ç ï¼‰
                    const preElement = fileViewer.querySelector('pre');
                    if (preElement) {
                        Prism.highlightElement(preElement);
                    }
                }
            } else {
                // Prismè¿˜æ²¡åŠ è½½å®Œæˆï¼Œç­‰å¾…åŠ è½½
                const checkPrism = setInterval(() => {
                    if (typeof Prism !== 'undefined') {
                        clearInterval(checkPrism);
                        applySyntaxHighlighting();
                    }
                }, 100);
                setTimeout(() => clearInterval(checkPrism), 5000);
            }
        }

        // æ ¹æ®æ–‡ä»¶æ‰©å±•åè¿”å›å¯¹åº”çš„ Prism è¯­è¨€ç±»
        function getLanguageClass(ext) {
            const pvfExtensions = [
                'act', 'ani', 'skl', 'lst', 'str', 'equ', 'stk', 'ai', 'aic', 'key', 'als',
                'chr', 'etc', 'dgn', 'map', 'shp', 'ora', 'atk', 'ui', 'mm', 'mob', 'npc',
                'obj', 'qst', 'til', 'dwm', 'twn'
            ];
            
            if (pvfExtensions.includes(ext)) {
                return 'language-pvf';
            }
            
            // å…¶ä»–å¸¸è§æ–‡ä»¶ç±»å‹
            const languageMap = {
                'js': 'language-javascript',
                'ts': 'language-typescript',
                'json': 'language-json',
                'xml': 'language-xml',
                'html': 'language-html',
                'css': 'language-css',
                'py': 'language-python',
                'lua': 'language-lua',
                'nut': 'language-squirrel',  // Squirrel è„šæœ¬è¯­è¨€
                'sql': 'language-sql',
                'txt': 'language-plaintext',
                'cfg': 'language-plaintext',
                'def': 'language-plaintext',
                'inc': 'language-plaintext'
            };
            
            return languageMap[ext] || 'language-plaintext';
        }

        async function extractFile() {
            if (!currentFile) return;

            showLoading(true);
            updateStatus('æ­£åœ¨å‡†å¤‡ä¸‹è½½æ–‡ä»¶...');

            try {
                // ä»ç¼“å­˜ä¸­è·å–æ–‡ä»¶å†…å®¹
                const cached = fileContentCache.get(currentFile);
                
                if (!cached || !cached.content) {
                    // å¦‚æœç¼“å­˜ä¸­æ²¡æœ‰ï¼Œä»æœåŠ¡å™¨è·å–
                    const response = await fetch(`/api/file?key=${encodeURIComponent(currentFile)}`);
                    if (!response.ok) {
                        throw new Error('æ— æ³•è·å–æ–‡ä»¶å†…å®¹');
                    }
                    const data = await response.json();
                    
                    // åˆ›å»ºä¸‹è½½
                    downloadFile(currentFile, data.content);
                } else {
                    // ä½¿ç”¨ç¼“å­˜çš„å†…å®¹
                    downloadFile(currentFile, cached.content);
                }
                
                hideModal(extractModal);
            } catch (error) {
                alert('ä¸‹è½½å¤±è´¥: ' + error.message);
            } finally {
                showLoading(false);
            }
        }

        // åˆ›å»ºä¸‹è½½é“¾æ¥å¹¶è§¦å‘ä¸‹è½½
        function downloadFile(filename, content) {
            try {
                // åˆ›å»ºBlobå¯¹è±¡
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                
                // åˆ›å»ºä¸‹è½½é“¾æ¥
                const url = URL.createObjectURL(blob);
                
                // åˆ›å»ºä¸´æ—¶é“¾æ¥å¹¶è§¦å‘ä¸‹è½½
                const a = document.createElement('a');
                a.href = url;
                a.download = filename.split('/').pop(); // åªä½¿ç”¨æ–‡ä»¶åï¼Œä¸åŒ…æ‹¬è·¯å¾„
                document.body.appendChild(a);
                a.click();
                
                // æ¸…ç†
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
                
                updateStatus('æ–‡ä»¶å·²ä¸‹è½½: ' + filename);
            } catch (error) {
                throw new Error('åˆ›å»ºä¸‹è½½é“¾æ¥å¤±è´¥: ' + error.message);
            }
        }

        async function savePvfFile() {
            const savePath = document.getElementById('savePathInput').value.trim();
            if (!savePath) {
                alert('è¯·è¾“å…¥ä¿å­˜è·¯å¾„');
                return;
            }

            showLoading(true);
            updateStatus('æ­£åœ¨ä¿å­˜ PVF æ–‡ä»¶...');

            try {
                const response = await fetch('/api/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ filePath: savePath })
                });

                const data = await response.json();
                
                if (data.success) {
                    alert('PVF æ–‡ä»¶å·²ä¿å­˜');
                } else {
                    alert('ä¿å­˜å¤±è´¥: ' + data.error);
                }
            } catch (error) {
                alert('ä¿å­˜å¤±è´¥: ' + error.message);
            } finally {
                showLoading(false);
                hideModal(saveModal);
            }
        }

        function formatSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(2) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // æ˜¾ç¤ºç©ºç™½å­—ç¬¦ï¼ˆä¸æ˜¾ç¤ºæ¢è¡Œç¬¦ï¼‰
        function showWhitespace(text) {
            // ç›´æ¥æ›¿æ¢ç©ºç™½å­—ç¬¦ä¸ºå¸¦æ ·å¼çš„HTML
            return text
                .replace(/\t/g, '<span class="whitespace-tab">â†’</span>')
                .replace(/ /g, '<span class="whitespace-space">Â·</span>');
        }

        function applyWhitespaceDisplay(container) {
            // æŸ¥æ‰¾æ‰€æœ‰æ–‡æœ¬èŠ‚ç‚¹ï¼Œæ›¿æ¢å…¶ä¸­çš„ Tab å’Œç©ºæ ¼
            const walker = document.createTreeWalker(
                container,
                NodeFilter.SHOW_TEXT,
                null,
                false
            );

            const textNodes = [];
            let node;
            while (node = walker.nextNode()) {
                // åªå¤„ç†æ–‡æœ¬èŠ‚ç‚¹ï¼Œå¹¶ä¸”ä¸åŒ…å« HTML æ ‡ç­¾
                if (node.textContent && !node.textContent.includes('<')) {
                    textNodes.push(node);
                }
            }

            textNodes.forEach(textNode => {
                const parent = textNode.parentNode;
                if (parent) {
                    // æ›¿æ¢ Tab
                    const parts = textNode.textContent.split('\t');
                    if (parts.length > 1) {
                        const fragment = document.createDocumentFragment();
                        for (let i = 0; i < parts.length; i++) {
                            fragment.appendChild(document.createTextNode(parts[i]));
                            if (i < parts.length - 1) {
                                const tabSpan = document.createElement('span');
                                tabSpan.className = 'whitespace-tab';
                                tabSpan.textContent = 'â†’';
                                fragment.appendChild(tabSpan);
                            }
                        }
                        parent.replaceChild(fragment, textNode);
                    }
                }
            });
        }

        // æŸ¥æ‰¾æ–‡ä»¶ï¼ˆä¸åŒºåˆ†å¤§å°å†™ï¼‰- é€šè¿‡å°è¯•ä¸åŒå˜ä½“
        async function findFileIgnoreCase(path) {
            // è·å–å½“å‰æ–‡ä»¶çš„ç›®å½•
            let currentDir = '';
            if (currentFile) {
                const lastSlashIndex = currentFile.lastIndexOf('/');
                if (lastSlashIndex > 0) {
                    currentDir = currentFile.substring(0, lastSlashIndex);
                }
            }

            // è½¬æ¢ä¸ºå°å†™ï¼ˆåç«¯å·²å®ç°å¤§å°å†™ä¸æ•æ„Ÿï¼‰
            const lowerPath = path.toLowerCase();

            // å°è¯•ä¸åŒçš„è·¯å¾„å˜ä½“
            const variations = [
                path,  // åŸå§‹è·¯å¾„ï¼ˆç›¸å¯¹æ ¹ç›®å½•ï¼‰
                lowerPath,  // å…¨å°å†™
                path.toUpperCase(),  // å…¨å¤§å†™
                // å¦‚æœå½“å‰åœ¨å­ç›®å½•ï¼Œå°è¯•æ·»åŠ å½“å‰ç›®å½•å‰ç¼€
                currentDir ? currentDir + '/' + path : null,
                currentDir ? currentDir + '/' + lowerPath : null,
                // å°è¯•åœ¨å¸¸è§çš„è„šæœ¬ç›®å½•ä¸‹æŸ¥æ‰¾
                'sqr/' + path,
                'sqr/' + lowerPath,
                'sqr/character/' + path,
                'sqr/character/' + lowerPath,
                // å°è¯•ç§»é™¤é¦–å­—æ¯å¤§å†™çš„è½¬æ¢
                lowerPath.split('/').map(part => part).join('/'),
            ].filter(v => v !== null);

            // ä¾æ¬¡å°è¯•æ¯ä¸ªå˜ä½“
            for (const variation of variations) {
                try {
                    const response = await fetch(`/api/file?key=${encodeURIComponent(variation)}`);
                    if (response.ok) {
                        // æ£€æŸ¥æ–‡ä»¶å†…å®¹æ˜¯å¦æœ‰æ•ˆï¼ˆä¸æ˜¯ç©ºå†…å®¹æˆ–é”™è¯¯ä¿¡æ¯ï¼‰
                        const data = await response.json();
                        if (data.content && data.content.trim().length > 0 && !data.error) {
                            console.log('Found file at:', variation);
                            return variation;
                        }
                    }
                } catch (error) {
                    // ç»§ç»­å°è¯•ä¸‹ä¸€ä¸ªå˜ä½“
                    continue;
                }
            }

            console.log('File not found for path:', path);
            return null;
        }

        // è¯†åˆ«å¹¶æ·»åŠ è·¯å¾„é“¾æ¥
        function addPathLinks(container) {
            // æ£€æŸ¥æ˜¯å¦æ˜¯ .lst æ–‡ä»¶
            const isLstFile = currentFile && currentFile.toLowerCase().endsWith('.lst');

            // åŒ¹é…è·¯å¾„çš„æ­£åˆ™è¡¨è¾¾å¼ï¼ˆåŒ…æ‹¬å¼•å·ä¸­çš„è·¯å¾„ï¼‰
            const pathRegex = /`([^`]*?\/?[^`]*?\.[a-zA-Z0-9]+)`|"([^"]*?\/?[^"]*?\.[a-zA-Z0-9]+)"|'([^']*?\/?[^']*?\.[a-zA-Z0-9]+)'/gi;

            const walker = document.createTreeWalker(
                container,
                NodeFilter.SHOW_TEXT,
                {
                    acceptNode: function(node) {
                        // åªå¤„ç†æ–‡æœ¬èŠ‚ç‚¹ï¼Œå¹¶ä¸”ä¸åŒ…å« HTML æ ‡ç­¾
                        if (node.textContent && !node.textContent.includes('<') && pathRegex.test(node.textContent)) {
                            return NodeFilter.FILTER_ACCEPT;
                        }
                        return NodeFilter.FILTER_REJECT;
                    }
                },
                false
            );

            const textNodes = [];
            let node;
            while (node = walker.nextNode()) {
                textNodes.push(node);
            }

            textNodes.forEach(textNode => {
                const parent = textNode.parentNode;
                if (parent) {
                    const fragment = document.createDocumentFragment();
                    let lastIndex = 0;
                    let match;

                    // é‡ç½®æ­£åˆ™è¡¨è¾¾å¼
                    pathRegex.lastIndex = 0;

                    while ((match = pathRegex.exec(textNode.textContent)) !== null) {
                        // æ·»åŠ åŒ¹é…å‰çš„æ–‡æœ¬
                        if (match.index > lastIndex) {
                            fragment.appendChild(document.createTextNode(textNode.textContent.substring(lastIndex, match.index)));
                        }

                        // æå–å®Œæ•´åŒ¹é…çš„æ–‡æœ¬å’Œå®é™…è·¯å¾„
                        const fullPath = match[0];
                        const backtickPath = match[1];      // åå¼•å·ä¸­çš„è·¯å¾„
                        const doubleQuotePath = match[2];   // åŒå¼•å·ä¸­çš„è·¯å¾„
                        const singleQuotePath = match[3];   // å•å¼•å·ä¸­çš„è·¯å¾„

                        // ç¡®å®šè·¯å¾„å’Œå¼•å·ç±»å‹
                        let path, quoteChar;
                        if (backtickPath) {
                            path = backtickPath;
                            quoteChar = '`';
                        } else if (doubleQuotePath) {
                            path = doubleQuotePath;
                            quoteChar = '"';
                        } else if (singleQuotePath) {
                            path = singleQuotePath;
                            quoteChar = "'";
                        } else {
                            continue;  // è·³è¿‡æ— æ•ˆåŒ¹é…
                        }

                        // æ·»åŠ å·¦å¼•å·
                        fragment.appendChild(document.createTextNode(quoteChar));

                        // åˆ›å»ºé“¾æ¥å…ƒç´ 
                        const link = document.createElement('span');
                        link.className = 'path-link';
                        link.textContent = path;
                        link.addEventListener('click', async (e) => {
                            e.stopPropagation();
                            // ä¸åŒºåˆ†å¤§å°å†™æŸ¥æ‰¾æ–‡ä»¶
                            const actualPath = await findFileIgnoreCase(path);
                            if (actualPath) {
                                loadFileContent(actualPath);
                            } else {
                                updateStatus('æ–‡ä»¶æœªæ‰¾åˆ°: ' + path);
                            }
                        });

                        fragment.appendChild(link);

                        // æ·»åŠ å³å¼•å·
                        fragment.appendChild(document.createTextNode(quoteChar));

                        // å¦‚æœæ˜¯ .lst æ–‡ä»¶ï¼Œåœ¨å¼•å·å¤–æ·»åŠ åç§°é¢„è§ˆ
                        if (isLstFile) {
                            const namePreview = document.createElement('span');
                            namePreview.className = 'name-preview';
                            namePreview.textContent = ' åŠ è½½ä¸­...';
                            fragment.appendChild(namePreview);

                            // å¼‚æ­¥åŠ è½½åç§°
                            loadNamePreview(path, namePreview);
                        }

                        lastIndex = pathRegex.lastIndex;
                    }

                    // æ·»åŠ å‰©ä½™çš„æ–‡æœ¬
                    if (lastIndex < textNode.textContent.length) {
                        fragment.appendChild(document.createTextNode(textNode.textContent.substring(lastIndex)));
                    }

                    parent.replaceChild(fragment, textNode);
                }
            });
        }

        // åŠ è½½åç§°é¢„è§ˆï¼ˆå¸¦ç¼“å­˜ï¼‰
        async function loadNamePreview(path, previewElement) {
            try {
                // æ£€æŸ¥ç¼“å­˜
                if (namePreviewCache.has(path)) {
                    const cachedName = namePreviewCache.get(path);
                    if (cachedName) {
                        previewElement.textContent = cachedName;
                        previewElement.style.display = 'inline';
                    } else {
                        previewElement.textContent = '';
                        previewElement.style.display = 'none';
                    }
                    return;
                }

                // æ£€æŸ¥æ˜¯å¦å·²æœ‰æ­£åœ¨è¿›è¡Œçš„è¯·æ±‚
                if (namePreviewPromises.has(path)) {
                    const promise = namePreviewPromises.get(path);
                    const name = await promise;
                    if (name) {
                        previewElement.textContent = name;
                        previewElement.style.display = 'inline';
                    } else {
                        previewElement.textContent = '';
                        previewElement.style.display = 'none';
                    }
                    return;
                }

                // åˆ›å»ºæ–°çš„è¯·æ±‚Promiseå¹¶ç¼“å­˜
                const promise = (async () => {
                    const actualPath = await findFileIgnoreCase(path);
                    if (!actualPath) {
                        namePreviewCache.set(path, '');
                        return '';
                    }

                    const response = await fetch(`/api/file?key=${encodeURIComponent(actualPath)}`);
                    if (!response.ok) {
                        namePreviewCache.set(path, '');
                        return '';
                    }

                    const data = await response.json();
                    const content = data.content;

                    // æå– [name] æ ‡ç­¾çš„å†…å®¹
                    const nameMatch = content.match(/\[name\]\s*\n\s*(.+?)(?:\n|$)/i);
                    if (nameMatch && nameMatch[1]) {
                        // ç§»é™¤æ‰€æœ‰ç±»å‹çš„å¼•å·ï¼šå•å¼•å·ã€åŒå¼•å·ã€åå¼•å·
                        const name = nameMatch[1].trim().replace(/^["'`]|["'`]$/g, '');
                        namePreviewCache.set(path, name);
                        return name;
                    } else {
                        // å°è¯•å…¶ä»–å¸¸è§çš„åç§°æ ‡ç­¾æ ¼å¼
                        const altNameMatch = content.match(/name\s*=\s*["'`]([^"'`]+)["'`]/i);
                        if (altNameMatch && altNameMatch[1]) {
                            const name = altNameMatch[1].trim();
                            namePreviewCache.set(path, name);
                            return name;
                        } else {
                            // å†å°è¯•æ²¡æœ‰å¼•å·çš„æ ¼å¼
                            const noQuoteMatch = content.match(/name\s*=\s*([^\s]+)/i);
                            if (noQuoteMatch && noQuoteMatch[1]) {
                                const name = noQuoteMatch[1].trim();
                                namePreviewCache.set(path, name);
                                return name;
                            } else {
                                namePreviewCache.set(path, '');
                                return '';
                            }
                        }
                    }
                })();

                namePreviewPromises.set(path, promise);

                // ç­‰å¾…ç»“æœå¹¶æ›´æ–°UI
                const name = await promise;
                if (name) {
                    previewElement.textContent = name;
                    previewElement.style.display = 'inline';
                } else {
                    previewElement.textContent = '';
                    previewElement.style.display = 'none';
                }
            } catch (error) {
                console.error('åŠ è½½åç§°é¢„è§ˆå¤±è´¥:', error);
                previewElement.textContent = '';
                previewElement.style.display = 'none';
                namePreviewCache.set(path, '');
            } finally {
                // æ¸…ç†Promiseç¼“å­˜
                namePreviewPromises.delete(path);
            }
        }

        // æ£€æŸ¥æ˜¯å¦æ˜¾ç¤ºç©ºç™½å­—ç¬¦
        let showWhitespaceMode = true; // é»˜è®¤æ˜¾ç¤ºç©ºç™½å­—ç¬¦

        // ç­‰å¾…DOMåŠ è½½å®Œæˆåæ·»åŠ äº‹ä»¶ç›‘å¬å™¨
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOMContentLoaded event fired');

            // äº‹ä»¶ç›‘å¬
            if (toggleSidebarBtn) {
                toggleSidebarBtn.addEventListener('click', () => toggleSidebar(true));
            }
            if (sidebarOverlay) {
                sidebarOverlay.addEventListener('click', () => toggleSidebar(false));
            }

            if (openBtn) {
                openBtn.addEventListener('click', () => showModal(openModal));
            }
            if (saveBtn) {
                saveBtn.addEventListener('click', () => showModal(saveModal));
            }
            if (editBtn) {
                editBtn.addEventListener('click', openEditModal);
            }
            if (extractBtn) {
                extractBtn.addEventListener('click', () => {
                    if (!currentFile) {
                        alert('æ²¡æœ‰é€‰ä¸­çš„æ–‡ä»¶');
                        return;
                    }
                    document.getElementById('extractFileName').textContent = currentFile;
                    showModal(extractModal);
                });
            }
            if (advancedSearchBtn) {
                advancedSearchBtn.addEventListener('click', () => showModal(searchModal));
            }

            // å¤åˆ¶è·¯å¾„æŒ‰é’®
            const copyPathBtn = document.getElementById('copyPathBtn');
            if (copyPathBtn) {
                copyPathBtn.addEventListener('click', () => {
                    if (!currentFile) {
                        alert('æ²¡æœ‰é€‰ä¸­çš„æ–‡ä»¶');
                        return;
                    }
                    navigator.clipboard.writeText(currentFile).then(() => {
                        updateStatus('è·¯å¾„å·²å¤åˆ¶: ' + currentFile);
                    }).catch(() => {
                        // é™çº§æ–¹æ¡ˆ
                        const textarea = document.createElement('textarea');
                        textarea.value = currentFile;
                        textarea.style.position = 'fixed';
                        textarea.style.opacity = '0';
                        document.body.appendChild(textarea);
                        textarea.select();
                        document.execCommand('copy');
                        document.body.removeChild(textarea);
                        updateStatus('è·¯å¾„å·²å¤åˆ¶: ' + currentFile);
                    });
                });
            }

            // å®šä½åˆ°ç›®å½•æŒ‰é’®
            const locateDirBtn = document.getElementById('locateDirBtn');
            if (locateDirBtn) {
                locateDirBtn.addEventListener('click', async () => {
                    if (!currentFile) {
                        alert('æ²¡æœ‰é€‰ä¸­çš„æ–‡ä»¶');
                        return;
                    }
                    
                    const lastSlashIndex = currentFile.lastIndexOf('/');
                    if (lastSlashIndex > 0) {
                        const dirPath = currentFile.substring(0, lastSlashIndex);
                        const fileName = currentFile.substring(lastSlashIndex + 1);
                        
                        // å…ˆåŠ è½½åˆ°ç›®æ ‡ç›®å½•
                        await loadFiles(dirPath);
                        
                        // åˆ‡æ¢åˆ°ç›®å½•æ ‡ç­¾é¡µ
                        document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
                        document.querySelector('.sidebar-tab[data-tab="tree"]').classList.add('active');
                        document.getElementById('fileTree').style.display = 'block';
                        document.getElementById('searchResults').style.display = 'none';
                        
                        // åœ¨ç§»åŠ¨ç«¯æ˜¾ç¤ºä¾§è¾¹æ 
                        if (window.innerWidth <= 768) {
                            toggleSidebar(true);
                        }
                        
                        // ç­‰å¾…DOMæ›´æ–°åé€‰ä¸­æ–‡ä»¶
                        setTimeout(() => {
                            // ç§»é™¤æ‰€æœ‰é€‰ä¸­çŠ¶æ€
                            document.querySelectorAll('.file-item.selected').forEach(item => {
                                item.classList.remove('selected');
                            });
                            
                            // é€‰ä¸­ç›®æ ‡æ–‡ä»¶
                            const fileItems = document.querySelectorAll('.file-item[data-is-file="true"]');
                            fileItems.forEach(item => {
                                if (item.dataset.key === currentFile) {
                                    item.classList.add('selected');
                                    item.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                }
                            });
                            updateStatus('å·²å®šä½åˆ°: ' + fileName);
                        }, 100);
                    } else {
                        await loadFiles('');
                        updateStatus('å·²å®šä½åˆ°æ ¹ç›®å½•');
                    }
                });
            }

            // æ‰“å¼€æ–‡ä»¶æ¨¡æ€æ¡†äº‹ä»¶ç›‘å¬å™¨
            const cancelOpenBtn = document.getElementById('cancelOpenBtn');
            const confirmOpenBtn = document.getElementById('confirmOpenBtn');
            const filePathInput = document.getElementById('filePathInput');
            if (cancelOpenBtn) {
                cancelOpenBtn.addEventListener('click', () => hideModal(openModal));
            }
            if (confirmOpenBtn) {
                confirmOpenBtn.addEventListener('click', openPvfFile);
            }
            if (filePathInput) {
                filePathInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') openPvfFile();
                });
            }

            const cancelExtractBtn = document.getElementById('cancelExtractBtn');
            const confirmExtractBtn = document.getElementById('confirmExtractBtn');
            if (cancelExtractBtn) {
                cancelExtractBtn.addEventListener('click', () => hideModal(extractModal));
            }
            if (confirmExtractBtn) {
                confirmExtractBtn.addEventListener('click', extractFile);
            }

            const destPathInput = document.getElementById('destPathInput');
            if (destPathInput) {
                destPathInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') extractFile();
                });
            }

            const cancelSaveBtn = document.getElementById('cancelSaveBtn');
            const confirmSaveBtn = document.getElementById('confirmSaveBtn');
            const savePathInput = document.getElementById('savePathInput');
            if (cancelSaveBtn) {
                cancelSaveBtn.addEventListener('click', () => hideModal(saveModal));
            }
            if (confirmSaveBtn) {
                confirmSaveBtn.addEventListener('click', savePvfFile);
            }
            if (savePathInput) {
                savePathInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') savePvfFile();
                });
            }

            // é«˜çº§æœç´¢æ¨¡æ€æ¡†äº‹ä»¶ç›‘å¬
            const cancelSearchBtn = document.getElementById('cancelSearchBtn');
            if (cancelSearchBtn) {
                cancelSearchBtn.addEventListener('click', () => hideModal(searchModal));
            }
            const confirmSearchBtn = document.getElementById('confirmSearchBtn');
            if (confirmSearchBtn) {
                confirmSearchBtn.addEventListener('click', performAdvancedSearch);
            }
            const searchKeywordInput = document.getElementById('searchKeywordInput');
            if (searchKeywordInput) {
                searchKeywordInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') performAdvancedSearch();
                });
            }

            // æœç´¢è¾“å…¥æ¡†äº‹ä»¶ç›‘å¬
            if (searchInput) {
                searchInput.addEventListener('input', async (e) => {
                    const query = e.target.value.trim();
                    if (!query) {
                        // æœç´¢ä¸ºç©ºæ—¶ï¼Œåˆ‡æ¢å›ç›®å½•æ ‡ç­¾é¡µå¹¶é‡æ–°åŠ è½½å½“å‰ç›®å½•
                        document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
                        document.querySelector('.sidebar-tab[data-tab="tree"]').classList.add('active');
                        document.getElementById('fileTree').style.display = 'block';
                        document.getElementById('searchResults').style.display = 'none';
                        loadFiles(currentPath);
                        return;
                    }

                    // æœ‰æœç´¢å†…å®¹æ—¶ï¼Œåˆ‡æ¢åˆ°æœç´¢ç»“æœæ ‡ç­¾é¡µ
                    document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
                    document.querySelector('.sidebar-tab[data-tab="search"]').classList.add('active');
                    document.getElementById('fileTree').style.display = 'none';
                    document.getElementById('searchResults').style.display = 'block';

                    try {
                        const response = await fetch(`/api/search?q=${encodeURIComponent(query)}`);
                        const data = await response.json();
                        
                        if (data.results && data.results.length > 0) {
                            renderFileTree(data.results.map(key => ({
                                key,
                                name: key.split('/').pop(),
                                isFile: true
                            })), '');
                        } else {
                            document.getElementById('searchResults').innerHTML = '<div style="padding: 20px; text-align: center; color: #858585;">æœªæ‰¾åˆ°åŒ¹é…çš„æ–‡ä»¶</div>';
                        }
                    } catch (error) {
                        console.error('æœç´¢å¤±è´¥:', error);
                    }
                });
            }

            // ç¼–ç åˆ‡æ¢æ—¶é‡æ–°åŠ è½½å½“å‰æ–‡ä»¶
            if (encodingSelect) {
                encodingSelect.addEventListener('change', async () => {
                    if (currentFile) {
                        showLoading(true);
                        updateStatus('æ­£åœ¨é‡æ–°åŠ è½½æ–‡ä»¶...');
                        try {
                            const response = await fetch(`/api/file?key=${encodeURIComponent(currentFile)}`);
                            const data = await response.json();
                            
                            const ext = currentFile.split('.').pop().toLowerCase();
                            const languageClass = getLanguageClass(ext);

                            const content = escapeHtml(data.content);
                            const preClass = languageClass;

                            fileViewer.innerHTML = `<pre class="${preClass}">${content}</pre>`;
                            updateStatus(`${currentFile.split('/').pop()} (ç¼–ç : ${encodingSelect.options[encodingSelect.selectedIndex].text})`);

                            // åº”ç”¨è¯­æ³•é«˜äº®
                            if (typeof Prism !== 'undefined') {
                                const preElement = fileViewer.querySelector('pre');
                                if (preElement) {
                                    Prism.highlightElement(preElement);
                                    // åœ¨è¯­æ³•é«˜äº®ååº”ç”¨ç©ºç™½å­—ç¬¦æ˜¾ç¤º
                                    if (showWhitespaceMode) {
                                        applyWhitespaceDisplay(preElement);
                                    }
                                    // æ·»åŠ è·¯å¾„é“¾æ¥
                                    addPathLinks(preElement);
                                }
                            } else {
                                // ç­‰å¾…PrismåŠ è½½å®Œæˆ
                                const checkPrism = setInterval(() => {
                                    if (typeof Prism !== 'undefined') {
                                        clearInterval(checkPrism);
                                        const preElement = fileViewer.querySelector('pre');
                                        if (preElement) {
                                            Prism.highlightElement(preElement);
                                            if (showWhitespaceMode) {
                                                applyWhitespaceDisplay(preElement);
                                            }
                                            addPathLinks(preElement);
                                        }
                                    }
                                }, 100);
                                setTimeout(() => clearInterval(checkPrism), 5000);
                            }
                        } catch (error) {
                            console.error('é‡æ–°åŠ è½½å¤±è´¥:', error);
                        } finally {
                            showLoading(false);
                        }
                    } else {
                        updateStatus(`ç¼–ç å·²åˆ‡æ¢ä¸º: ${encodingSelect.options[encodingSelect.selectedIndex].text}`);
                    }
                });
            }

            // åˆ‡æ¢ç©ºç™½å­—ç¬¦æ˜¾ç¤º
            const toggleWhitespaceBtn = document.getElementById('toggleWhitespaceBtn');
            if (toggleWhitespaceBtn) {
                toggleWhitespaceBtn.addEventListener('click', () => {
                    showWhitespaceMode = !showWhitespaceMode;
                    
                    if (showWhitespaceMode) {
                        toggleWhitespaceBtn.style.background = '#007acc';
                        toggleWhitespaceBtn.style.color = 'white';
                    } else {
                        toggleWhitespaceBtn.style.background = '#3c3c3c';
                        toggleWhitespaceBtn.style.color = '#d4d4d4';
                    }
                    
                    // å¦‚æœæœ‰å½“å‰æ–‡ä»¶ï¼Œé‡æ–°åŠ è½½
                    if (currentFile) {
                        loadFileContent(currentFile);
                    }
                });
            }

            // åˆå§‹åŒ–æŒ‰é’®çŠ¶æ€ï¼ˆé»˜è®¤æ¿€æ´»ï¼‰
            if (toggleWhitespaceBtn) {
                toggleWhitespaceBtn.style.background = '#007acc';
                toggleWhitespaceBtn.style.color = 'white';
            }

            // æ ‡ç­¾é¡µåˆ‡æ¢
            const sidebarTabs = document.querySelectorAll('.sidebar-tab');
            if (sidebarTabs.length > 0) {
                sidebarTabs.forEach(tab => {
                    tab.addEventListener('click', () => {
                        // ç§»é™¤æ‰€æœ‰activeç±»
                        document.querySelectorAll('.sidebar-tab').forEach(t => t.classList.remove('active'));
                        
                        // æ·»åŠ activeç±»åˆ°å½“å‰æ ‡ç­¾
                        tab.classList.add('active');
                        
                        // åˆ‡æ¢æ˜¾ç¤ºå†…å®¹
                        const tabName = tab.dataset.tab;
                        const fileTree = document.getElementById('fileTree');
                        const searchResults = document.getElementById('searchResults');
                        
                        if (fileTree && searchResults) {
                            if (tabName === 'tree') {
                                fileTree.style.display = 'block';
                                searchResults.style.display = 'none';
                            } else {
                                fileTree.style.display = 'none';
                                searchResults.style.display = 'block';
                            }
                        }
                    });
                });
            }

            // æ˜¾ç¤ºæœç´¢ç»“æœ
            function showSearchResults(results) {
                const searchResults = document.getElementById('searchResults');
                
                if (!searchResults) return;
                
                if (!results || results.length === 0) {
                    searchResults.innerHTML = '<div style="padding: 20px; text-align: center; color: #858585;">æœªæ‰¾åˆ°åŒ¹é…çš„æ–‡ä»¶</div>';
                    return;
                }
                
                let html = `<div style="padding: 8px 10px; color: #858585; font-size: 12px;">æ‰¾åˆ° ${results.length} ä¸ªç»“æœ</div>`;
                
                results.forEach(item => {
                    html += `
                        <div class="search-result-item" data-key="${item.key}">
                            <div class="search-result-name">ğŸ“„ ${item.name}</div>
                            <div class="search-result-path">${item.key}</div>
                            ${item.match ? `<div class="search-result-match">${item.match}</div>` : ''}
                        </div>
                    `;
                });
                
                searchResults.innerHTML = html;
                
                // æ·»åŠ ç‚¹å‡»äº‹ä»¶
                searchResults.querySelectorAll('.search-result-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const key = item.dataset.key;
                        loadFileContent(key);
                        
                        // åœ¨ç§»åŠ¨ç«¯å…³é—­ä¾§è¾¹æ 
                        if (window.innerWidth <= 768) {
                            toggleSidebar(false);
                        }
                    });
                });
            }

            // æ£€æŸ¥çŠ¶æ€
            fetch('/api/status').then(res => res.json()).then(data => {
                if (data.hasOpenFile) {
                    saveBtn.disabled = false;
                    loadFiles('');
                    updateStatus(`å·²æ‰“å¼€: ${data.pvfPath.split('/').pop()}`);
                } else {
                    if (fileTree) {
                        fileTree.innerHTML = '<div style="padding: 20px; text-align: center; color: #858585;">è¯·å…ˆæ‰“å¼€ PVF æ–‡ä»¶</div>';
                    }
                }
            }).catch(error => {
                console.error('Status check failed:', error);
                if (fileTree) {
                    fileTree.innerHTML = '<div style="padding: 20px; text-align: center; color: #ff6b6b;">æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨</div>';
                }
            }).finally(() => {
                // ç¡®ä¿åŠ è½½çŠ¶æ€è¢«éšè—
                showLoading(false);
            });

            // ç§»åŠ¨ç«¯é»˜è®¤æŠ˜å ä¾§è¾¹æ 
            if (window.innerWidth <= 768 && sidebar) {
                sidebar.classList.add('collapsed');
            }

            // ç›‘å¬å±å¹•å°ºå¯¸å˜åŒ–
            window.addEventListener('resize', () => {
                if (window.innerWidth <= 768) {
                    if (sidebar) {
                        sidebar.classList.add('collapsed');
                    }
                }
            });

        // ç¼–è¾‘åŠŸèƒ½
        async function openEditModal() {
            if (!currentFile) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶');
                return;
            }

            try {
                const response = await fetch(`/api/file?key=${encodeURIComponent(currentFile)}`);
                const data = await response.json();

                document.getElementById('editFileName').textContent = currentFile;
                document.getElementById('editFileContent').value = data.content;
                showModal(editModal);
            } catch (error) {
                console.error('åŠ è½½æ–‡ä»¶å†…å®¹å¤±è´¥:', error);
                alert('åŠ è½½æ–‡ä»¶å†…å®¹å¤±è´¥');
            }
        }

        async function saveEditedFile() {
            if (!currentFile) {
                alert('æ²¡æœ‰æ–‡ä»¶å¯ä»¥ä¿å­˜');
                return;
            }

            const content = document.getElementById('editFileContent').value;
            const encoding = encodingSelect.value;

            showLoading(true);
            updateStatus('æ­£åœ¨ä¿å­˜æ–‡ä»¶...');

            try {
                const response = await fetch('/api/save-file', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        key: currentFile,
                        content: content,
                        encoding: encoding
                    })
                });

                const data = await response.json();

                if (data.success) {
                    hideModal(editModal);
                    updateStatus('æ–‡ä»¶å·²ä¿å­˜');
                    // é‡æ–°åŠ è½½æ–‡ä»¶å†…å®¹ä»¥æ˜¾ç¤ºæ›´æ”¹
                    await loadFileContent(currentFile);
                } else {
                    alert('ä¿å­˜å¤±è´¥: ' + (data.error || 'æœªçŸ¥é”™è¯¯'));
                }
            } catch (error) {
                console.error('ä¿å­˜æ–‡ä»¶å¤±è´¥:', error);
                alert('ä¿å­˜æ–‡ä»¶å¤±è´¥: ' + String(error));
            } finally {
                showLoading(false);
            }
        }

        // ç¼–è¾‘æ¨¡æ€æ¡†äº‹ä»¶ç›‘å¬
        const cancelEditBtn = document.getElementById('cancelEditBtn');
        const confirmEditBtn = document.getElementById('confirmEditBtn');
        if (cancelEditBtn) {
            cancelEditBtn.addEventListener('click', () => hideModal(editModal));
        }
        if (confirmEditBtn) {
            confirmEditBtn.addEventListener('click', saveEditedFile);
        }

        // æ”¯æŒå¿«æ·é”®
        document.addEventListener('keydown', (e) => {
            // Ctrl+S: ä¿å­˜
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                if (editModal && editModal.classList.contains('show')) {
                    saveEditedFile();
                } else if (saveBtn && !saveBtn.disabled) {
                    savePvfFile();
                }
            }
            
            // Ctrl+F: æœç´¢
            if (e.ctrlKey && e.key === 'f') {
                e.preventDefault();
                if (searchModal && !searchModal.classList.contains('show')) {
                    showModal(searchModal);
                    const searchKeywordInput = document.getElementById('searchKeywordInput');
                    if (searchKeywordInput) {
                        searchKeywordInput.focus();
                    }
                }
            }
            
            // Ctrl+B: æ‰¹é‡æ¨¡å¼åˆ‡æ¢
            if (e.ctrlKey && e.key === 'b') {
                e.preventDefault();
                if (batchModeBtn) {
                    batchModeBtn.click();
                }
            }
            
            // Ctrl+E: ç¼–è¾‘å½“å‰æ–‡ä»¶
            if (e.ctrlKey && e.key === 'e') {
                e.preventDefault();
                if (editBtn && !editBtn.disabled && editModal && !editModal.classList.contains('show')) {
                    openEditModal();
                }
            }
            
            // Escape: å…³é—­æ¨¡æ€æ¡†
            if (e.key === 'Escape') {
                const modals = document.querySelectorAll('.modal.show');
                modals.forEach(modal => {
                    hideModal(modal);
                });
            }
            
            // Ctrl+O: æ‰“å¼€æ–‡ä»¶
            if (e.ctrlKey && e.key === 'o') {
                e.preventDefault();
                if (openModal && !openModal.classList.contains('show')) {
                    showModal(openModal);
                    const filePathInput = document.getElementById('filePathInput');
                    if (filePathInput) {
                        filePathInput.focus();
                    }
                }
            }
        });

        // æ‰¹é‡æ“ä½œåŠŸèƒ½
        if (batchModeBtn) {
            batchModeBtn.addEventListener('click', () => {
                batchMode = !batchMode;
                batchModeBtn.textContent = batchMode ? 'é€€å‡ºæ‰¹é‡' : 'æ‰¹é‡';
                batchModeBtn.style.background = batchMode ? '#007acc' : '#3c3c3c';
                
                if (batchMode && batchActions) {
                    batchActions.classList.add('show');
                } else {
                    if (batchActions) {
                        batchActions.classList.remove('show');
                    }
                    clearSelection();
                }
                
                // é‡æ–°åŠ è½½å½“å‰ç›®å½•ä»¥æ˜¾ç¤º/éšè—å¤é€‰æ¡†
                loadFiles(currentPath);
            });
        }

        function clearSelection() {
            selectedFiles.clear();
            updateBatchUI();
            
            // æ¸…é™¤æ‰€æœ‰å¤é€‰æ¡†
            if (fileTree) {
                fileTree.querySelectorAll('.checkbox input[type="checkbox"]').forEach(cb => {
                    cb.checked = false;
                });
            }
        }

        function updateBatchUI() {
            const count = selectedFiles.size;
            const selectedCountEl = document.getElementById('selectedCount');
            if (selectedCountEl) {
                selectedCountEl.textContent = count;
            }
            
            if (count > 0 && batchActions) {
                batchActions.classList.add('show');
            } else if (!batchMode && batchActions) {
                batchActions.classList.remove('show');
            }
        }

        // ç›‘å¬å¤é€‰æ¡†å˜åŒ–
        if (fileTree) {
            fileTree.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox' && e.target.dataset.key) {
                    const key = e.target.dataset.key;
                    if (e.target.checked) {
                        selectedFiles.add(key);
                    } else {
                        selectedFiles.delete(key);
                    }
                    updateBatchUI();
                }
            });
        }

        // æ¸…é™¤é€‰æ‹©æŒ‰é’®
        const clearSelectionBtn = document.getElementById('clearSelectionBtn');
        if (clearSelectionBtn) {
            clearSelectionBtn.addEventListener('click', clearSelection);
        }

        // æ‰¹é‡æå–åŠŸèƒ½
        const batchExtractBtn = document.getElementById('batchExtractBtn');
        if (batchExtractBtn) {
            batchExtractBtn.addEventListener('click', () => {
                if (selectedFiles.size === 0) {
                    alert('è¯·å…ˆé€‰æ‹©è¦æå–çš„æ–‡ä»¶');
                    return;
                }
                
                const batchExtractCount = document.getElementById('batchExtractCount');
                if (batchExtractCount) {
                    batchExtractCount.textContent = selectedFiles.size;
                }
                showModal(batchExtractModal);
            });
        }

        async function performBatchExtract() {
            const destPath = document.getElementById('batchDestPathInput').value.trim();
            if (!destPath) {
                alert('è¯·è¾“å…¥ç›®æ ‡è·¯å¾„');
                return;
            }

            showLoading(true);
            updateStatus(`æ­£åœ¨æå– ${selectedFiles.size} ä¸ªæ–‡ä»¶...`);

            try {
                const response = await fetch('/api/batch-extract', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        keys: Array.from(selectedFiles),
                        destPath: destPath
                    })
                });

                const data = await response.json();

                if (data.success) {
                    hideModal(batchExtractModal);
                    updateStatus(`æ‰¹é‡æå–å®Œæˆï¼šæˆåŠŸ ${data.successCount}/${data.total}`);
                    
                    if (data.successCount < data.total) {
                        const failed = data.results.filter(r => !r.success);
                        console.error('éƒ¨åˆ†æ–‡ä»¶æå–å¤±è´¥:', failed);
                    }
                } else {
                    alert('æ‰¹é‡æå–å¤±è´¥: ' + (data.error || 'æœªçŸ¥é”™è¯¯'));
                }
            } catch (error) {
                console.error('æ‰¹é‡æå–å¤±è´¥:', error);
                alert('æ‰¹é‡æå–å¤±è´¥: ' + String(error));
            } finally {
                showLoading(false);
            }
        }

        // æ‰¹é‡æå–æ¨¡æ€æ¡†äº‹ä»¶ç›‘å¬å™¨
        const cancelBatchExtractBtn = document.getElementById('cancelBatchExtractBtn');
        const confirmBatchExtractBtn = document.getElementById('confirmBatchExtractBtn');
        if (cancelBatchExtractBtn) {
            cancelBatchExtractBtn.addEventListener('click', () => hideModal(batchExtractModal));
        }
        if (confirmBatchExtractBtn) {
            confirmBatchExtractBtn.addEventListener('click', performBatchExtract);
        }

        // ä¹¦ç­¾ç¼–è¾‘æ¨¡æ€æ¡†äº‹ä»¶ç›‘å¬å™¨
        const cancelEditBookmarkBtn = document.getElementById('cancelEditBookmarkBtn');
        const confirmEditBookmarkBtn = document.getElementById('confirmEditBookmarkBtn');
        if (cancelEditBookmarkBtn) {
            cancelEditBookmarkBtn.addEventListener('click', () => hideModal(editBookmarkModal));
        }
        if (confirmEditBookmarkBtn) {
            confirmEditBookmarkBtn.addEventListener('click', saveBookmarkName);
        }

        // ä¹¦ç­¾åŠŸèƒ½
        function addBookmark() {
            if (!currentFile) {
                alert('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªæ–‡ä»¶');
                return;
            }

            // æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨
            const exists = bookmarks.some(b => b.key === currentFile);
            if (exists) {
                alert('è¯¥ä¹¦ç­¾å·²å­˜åœ¨');
                return;
            }

            const fileName = currentFile.split('/').pop();
            const bookmark = {
                key: currentFile,
                name: fileName,
                addedAt: new Date().toISOString()
            };

            bookmarks.push(bookmark);
            saveBookmarks();
            updateStatus('å·²æ·»åŠ ä¹¦ç­¾: ' + fileName);
        }

        function removeBookmark(key) {
            bookmarks = bookmarks.filter(b => b.key !== key);
            saveBookmarks();
            renderBookmarks();
            updateStatus('å·²åˆ é™¤ä¹¦ç­¾');
        }

        function editBookmark(key) {
            const bookmark = bookmarks.find(b => b.key === key);
            if (!bookmark) return;

            document.getElementById('editBookmarkPath').textContent = bookmark.key;
            document.getElementById('editBookmarkName').value = bookmark.name;
            document.getElementById('editBookmarkName').dataset.key = key;

            showModal(editBookmarkModal);
        }

        function saveBookmarkName() {
            const input = document.getElementById('editBookmarkName');
            const key = input.dataset.key;
            const newName = input.value.trim();

            if (!newName) {
                alert('åˆ«åä¸èƒ½ä¸ºç©º');
                return;
            }

            const bookmark = bookmarks.find(b => b.key === key);
            if (bookmark) {
                bookmark.name = newName;
                saveBookmarks();
                renderBookmarks();
                updateStatus('ä¹¦ç­¾åˆ«åå·²æ›´æ–°');
            }

            hideModal(editBookmarkModal);
        }

        // æ·»åŠ ä¹¦ç­¾æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
        if (addBookmarkBtn) {
            addBookmarkBtn.addEventListener('click', addBookmark);
        }

        // é¡µé¢åŠ è½½å®ŒæˆååŠ è½½ä¹¦ç­¾ã€PVF æ–‡ä»¶åˆ—è¡¨å’Œæ–‡ä»¶æ ‘
        window.addEventListener('load', async () => {
            console.log('Window loaded, starting initialization...');

            // æ£€æŸ¥å…³é”®DOMå…ƒç´ æ˜¯å¦å­˜åœ¨
            if (!fileTree) {
                console.error('fileTree element not found!');
                alert('é¡µé¢åˆå§‹åŒ–å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
                return;
            }

            console.log('DOM elements initialized successfully');

            // åŠ è½½ä¹¦ç­¾å’ŒPVFæ–‡ä»¶åˆ—è¡¨
            await Promise.all([
                loadBookmarks(),
                loadPvfFiles()
            ]);

            // ç›´æ¥åŠ è½½æ–‡ä»¶åˆ—è¡¨
            loadFiles();

            // è°ƒè¯•ï¼šæ£€æŸ¥ä¹¦ç­¾èœå•å†…å®¹
            setTimeout(() => {
                const bookmarkMenu = document.getElementById('bookmarkMenu');
                const pvfFileMenu = document.getElementById('pvfFileMenu');
                console.log('Bookmark menu HTML:', bookmarkMenu?.innerHTML);
                console.log('PVF file menu HTML:', pvfFileMenu?.innerHTML);
                console.log('Bookmarks count:', bookmarks.length);
            }, 1000);
        });

        // æ£€æŸ¥æœåŠ¡å™¨æ˜¯å¦å‡†å¤‡å¥½å¹¶åŠ è½½æ–‡ä»¶åˆ—è¡¨
        async function checkAndLoadFiles(retryCount = 0) {
            console.log('checkAndLoadFiles called, retryCount:', retryCount);
            console.log('fileTree element:', fileTree);

            try {
                console.log('Fetching /api/files?path=');
                const response = await fetch('/api/files?path=');
                console.log('Response status:', response.status);

                const data = await response.json();
                console.log('Response data:', data);

                if (data.error) {
                    console.log('PVFæ–‡ä»¶å°šæœªæ‰“å¼€ï¼Œç­‰å¾…ä¸­...');
                    fileTree.innerHTML = `<div style="padding: 20px; text-align: center; color: #858585;">æ­£åœ¨åŠ è½½PVFæ–‡ä»¶... (${retryCount + 1}s)</div>`;
                    if (retryCount < 30) { // æœ€å¤šç­‰å¾…30ç§’
                        setTimeout(() => checkAndLoadFiles(retryCount + 1), 1000);
                    } else {
                        fileTree.innerHTML = '<div style="padding: 20px; text-align: center; color: #ff6b6b;">åŠ è½½è¶…æ—¶ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•</div>';
                    }
                } else {
                    // PVFå·²å‡†å¤‡å¥½ï¼Œç›´æ¥æ¸²æŸ“æ–‡ä»¶åˆ—è¡¨
                    console.log('PVFå·²å‡†å¤‡å¥½ï¼Œæ¸²æŸ“æ–‡ä»¶åˆ—è¡¨');
                    console.log('Files count:', data.files?.length);
                    currentPath = '';
                    currentFile = null;
                    updateBreadcrumb('');
                    renderFileTree(data.files, '');
                }
            } catch (error) {
                console.error('æœåŠ¡å™¨å°šæœªå‡†å¤‡å¥½ï¼Œç­‰å¾…ä¸­... é”™è¯¯:', error);
                fileTree.innerHTML = `<div style="padding: 20px; text-align: center; color: #858585;">æ­£åœ¨è¿æ¥æœåŠ¡å™¨... (${retryCount + 1}s)</div>`;
                if (retryCount < 30) {
                    setTimeout(() => checkAndLoadFiles(retryCount + 1), 1000);
                } else {
                    fileTree.innerHTML = '<div style="padding: 20px; text-align: center; color: #ff6b6b;">æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨</div>';
                }
            }
        }

        // é¼ æ ‡æ‚¬åœæ—¶æ›´æ–°ä¹¦ç­¾èœå•
        const menuItems = document.querySelectorAll('.menu-item');
        if (menuItems.length > 1) {
            menuItems[1].addEventListener('mouseenter', () => {
                // å…ˆå…³é—­æ‰€æœ‰å…¶ä»–èœå•
                document.querySelectorAll('.menu-dropdown').forEach(dropdown => {
                    if (dropdown.id !== 'bookmarkMenu') {
                        dropdown.classList.remove('show');
                    }
                });
                renderBookmarks();
            });
        }

        // é¼ æ ‡æ‚¬åœæ—¶æ›´æ–°æ–‡ä»¶èœå•
        const fileMenu = document.getElementById('fileMenu');
        if (fileMenu) {
            fileMenu.addEventListener('mouseenter', () => {
                // å…ˆå…³é—­æ‰€æœ‰å…¶ä»–èœå•
                document.querySelectorAll('.menu-dropdown').forEach(dropdown => {
                    if (dropdown.id !== 'pvfFileMenu') {
                        dropdown.classList.remove('show');
                    }
                });
                loadPvfFiles();
            });
        }

        // ç‚¹å‡»åˆ‡æ¢æ–‡ä»¶èœå•æ˜¾ç¤ºï¼ˆç§»åŠ¨ç«¯æ”¯æŒï¼‰
        if (fileMenu) {
            fileMenu.addEventListener('click', (e) => {
                // å¦‚æœç‚¹å‡»çš„æ˜¯èœå•é¡¹æœ¬èº«ï¼Œè€Œä¸æ˜¯ä¸‹æ‹‰èœå•ä¸­çš„é¡¹ç›®ï¼Œåˆ™åˆ‡æ¢æ˜¾ç¤º
                if (e.target.closest('.menu-dropdown-item')) {
                    return; // è®©ä¸‹æ‹‰èœå•é¡¹çš„ç‚¹å‡»äº‹ä»¶å¤„ç†
                }
                e.stopPropagation();
                e.preventDefault();
                
                // å…ˆå…³é—­æ‰€æœ‰å…¶ä»–èœå•
                document.querySelectorAll('.menu-dropdown').forEach(dropdown => {
                    if (dropdown.id !== 'pvfFileMenu') {
                        dropdown.classList.remove('show');
                    }
                });
                
                const dropdown = document.getElementById('pvfFileMenu');
                if (dropdown) {
                    dropdown.classList.toggle('show');
                    loadPvfFiles();
                }
            });
        }

        // ç‚¹å‡»åˆ‡æ¢ä¹¦ç­¾èœå•æ˜¾ç¤ºï¼ˆç§»åŠ¨ç«¯æ”¯æŒï¼‰
        if (menuItems.length > 1) {
            menuItems[1].addEventListener('click', (e) => {
                e.stopPropagation();
                
                // å…ˆå…³é—­æ‰€æœ‰å…¶ä»–èœå•
                document.querySelectorAll('.menu-dropdown').forEach(dropdown => {
                    if (dropdown.id !== 'bookmarkMenu') {
                        dropdown.classList.remove('show');
                    }
                });
                
                const dropdown = document.getElementById('bookmarkMenu');
                if (dropdown) {
                    dropdown.classList.toggle('show');
                    renderBookmarks();
                }
            });
        }

        // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­èœå•
        document.addEventListener('click', () => {
            document.querySelectorAll('.menu-dropdown').forEach(dropdown => {
                dropdown.classList.remove('show');
            });
        });
        }); // å…³é—­ DOMContentLoaded

        // ç§»é™¤backBtnç›¸å…³çš„ä»£ç ï¼ˆå› ä¸ºå·²åˆ é™¤backBtnï¼‰
        // backBtn.style.display = 'flex'; // å·²åˆ é™¤
    </script>
</body>
</html>